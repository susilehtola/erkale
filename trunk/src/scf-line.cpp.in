/* Resticted case */
#if defined(RESTRICTED) && defined(DFT)
void SCF::RDFT_ls(rscf_t & sol, const std::vector<double> & occs, const convergence_t conv, const dft_t dft) const

#elif defined(RESTRICTED) && defined(HF)
void SCF::RHF_ls(rscf_t & sol, const std::vector<double> & occs, const convergence_t conv) const

#elif defined(UNRESTRICTED) && defined(DFT)
void SCF::UDFT_ls(uscf_t & sol, const std::vector<double> & occa, const std::vector<double> & occb, const convergence_t conv, const dft_t dft) const

#elif defined(UNRESTRICTED) && defined(HF)
void SCF::UHF_ls(uscf_t & sol, const std::vector<double> & occa, const std::vector<double> & occb, const convergence_t conv) const
#elif defined(UNRESTRICTED) && defined(_ROHF)
void SCF::ROHF_ls(uscf_t & sol, int Nel_alpha, int Nel_beta, const convergence_t conv) const

#elif defined(DFT) && defined(FULLHOLE)
size_t XRSSCF::full_hole_ls(size_t xcatom, uscf_t & sol, convergence_t conv, dft_t dft, bool xch) const

#elif defined(DFT) && defined(HALFHOLE)
size_t XRSSCF::half_hole_ls(size_t xcatom, uscf_t & sol, convergence_t conv, dft_t dft) const
#endif
{

#if defined(_ROHF)
  // Occupations
  std::vector<double> occa;
  std::vector<double> occb;

  if(basisp->get_Nnuc()==1) {
    occa=atomic_occupancy(Nel_alpha);
    occb=atomic_occupancy(Nel_beta);
  } else {
    occa=std::vector<double>(Nel_alpha,1.0);
    occb=std::vector<double>(Nel_beta,1.0);
  }

#elif ( defined(HALFHOLE) || defined(FULLHOLE) )
  // Occupation vector of spin up and spin down
  std::vector<double> occa;
  std::vector<double> occb;
#endif

  // Determine number of occupied states
#if !defined(HALFHOLE) && !defined(FULLHOLE)
#if defined(RESTRICTED)
  size_t nocc;
  for(nocc=occs.size()-1;nocc<occs.size();nocc--)
    if(occs[nocc]>0)
      break;
  nocc++;
#else
  size_t nocca;
  for(nocca=occa.size()-1;nocca<occa.size();nocca--)
    if(occa[nocca]>0)
      break;
  nocca++;
  
  size_t noccb;
  for(noccb=occb.size()-1;noccb<occb.size();noccb--)
    if(occb[noccb]>0)
      break;
  noccb++;
#endif
#endif


  Timer t;
  Timer ttot;

  // Dipole moment
  arma::vec dipmom;
  double olddip;

  // Tolerance for screening and screening efficiency
  double tol;

  // Determine tolerance to use
  if(strictint)
    tol=STRICTTOL;
  else
    tol=ROUGHTOL;

  // Change in energy from last iteration
  double deltaE=0;

  // Maximum and RMS differences of AO density matrix
  double rmsdiff=0.0, maxdiff=0.0;
#ifndef RESTRICTED
  double rmsdiffa=0.0, maxdiffa=0.0;
  double rmsdiffb=0.0, maxdiffb=0.0;
#endif

  if(verbose)
    printf("\n ******* Initialization of run ********\n");

#ifdef RESTRICTED
  if(sol.C.n_rows!=Nbf)
#else
    if(sol.Ca.n_rows!=Nbf || sol.Cb.n_rows!=Nbf)
#endif
      {

	if(guess!=COREGUESS)
	  throw std::runtime_error("No starting guess, and use of core guess disallowed!\n");
	
#ifdef RESTRICTED
	sol.H=Hcore;
#else
	sol.Ha=Hcore;
	sol.Hb=Hcore;
#endif

#if defined(HALFHOLE)
    diagonalize_hch(sol);
#elif defined(FULLHOLE)
    diagonalize_fch(sol);
#elif defined(RESTRICTED)
    diagonalize(sol);
#else
    diagonalize(sol);
#endif

	if(verbose)
	  printf("\nCore guess formed in %s.\n",t.elapsed().c_str());
	
      } else {
      // Got correctly sized input guess.

      if(verbose)
        printf("\nUsing input guess for orbitals.\n");
    }
  fflush(stdout);

#if defined(RESTRICTED)
  sol.P=form_density(sol.C,occs);
#else
  sol.Pa=form_density(sol.Ca,occa);
  sol.Pb=form_density(sol.Cb,occb);
  sol.P=sol.Pa+sol.Pb;
#endif
  
  
#if defined(FULLHOLE) || defined(HALFHOLE)
  size_t ixc_orb=0;
#endif
  
#ifdef DFT
  // Fraction of exact exchange
  double kfrac=exact_exchange(dft.x_func);

  if(verbose) {
    if(kfrac!=0.0)
      printf("\nUsing hybrid exchange with % .3f of exact exchange.\n",kfrac*100);
    else
      printf("\nA pure exchange functional used, no exact exchange.\n");
  }

  DFTGrid grid(basisp,verbose,dft_lobatto);
#endif

  // Sparse output to stderr
  if(verbose) {
    fprintf(stderr,"Running ");
#if defined(RESTRICTED) || defined(_ROHF)
    fprintf(stderr,"restricted ");
#else
    fprintf(stderr,"unrestricted ");
#endif

#ifndef DFT
#ifdef _ROHF
    fprintf(stderr,"open-shell ");
#endif
    fprintf(stderr,"HF ");
#else
    if(dft.c_func>0) {
      // Correlation exists.
      fprintf(stderr,"%s-%s ",get_keyword(dft.x_func).c_str(),get_keyword(dft.c_func).c_str());
    } else
      fprintf(stderr,"%s ",get_keyword(dft.x_func).c_str());
#endif

    fprintf(stderr,"calculation");
    if(densityfit)
      fprintf(stderr," with density fitting");

#ifdef DFT
#if (defined(FULLHOLE) || defined(HALFHOLE))
    if(densityfit)
      fprintf(stderr," and ");
    else
      fprintf(stderr," with ");
#ifdef FULLHOLE
    fprintf(stderr,"full core hole");
    if(xch)
      fprintf(stderr," (XCH)");
#else // half hole
    fprintf(stderr,"half core hole");
#endif
#endif

#endif // end DFT clause
    fprintf(stderr," using line search.\n");
    fprintf(stderr,"%6s %16s %10s  %9s  %9s  %8s %10s\n","","E","dE","RMS dens","MAX dens","dip mom","titer (s)");
  }
  fflush(stdout);
  fflush(stderr);

  // Solution of last iteration
#ifdef RESTRICTED
  rscf_t oldsol;
#else
  uscf_t oldsol;
#endif

  bool converged=false;
  size_t nfock=0;

  // Loop:
  for(int iiter=1;iiter<=maxiter;iiter++) {
    Timer titer;
    
    if(verbose) {
      printf("\n ******* Iteration %4i ********\n",iiter);
      fprintf(stderr,"Iteration %i\n",iiter);
      fflush(stderr);
      fflush(stdout);
    }

    // Save solution
    oldsol=sol;

    // LH and RH solutions.
#ifdef RESTRICTED
    rscf_t lhsol(sol);
    rscf_t rhsol(sol);
#else
    uscf_t lhsol(sol);
    uscf_t rhsol(sol);
#endif

#ifdef DFT
    {
      Timer tgrid;
#ifdef RESTRICTED
      // Form DFT quadrature grid
      grid.construct(lhsol.P,dft.gridtol,dft.x_func,dft.c_func);
#else
      // Form DFT quadrature grid
      grid.construct(lhsol.Pa,sol.Pb,dft.gridtol,dft.x_func,dft.c_func);
#endif
      fflush(stdout);
      
      if(verbose) {
	fprintf(stderr,"%-66s %10.3f\n","    DFT grid formation",tgrid.get());
	fflush(stderr);
	t.set();
      }
    }
#endif // ifdef DFT

    // Form the LHS Fock operator.
#ifdef RESTRICTED
    // Restricted case.
#if defined(HF)
    Fock_RHF(lhsol,occs,conv,oldsol,tol);
#elif defined(DFT)
    Fock_RDFT(lhsol,occs,conv,dft,oldsol,grid,tol);
#endif
#else
#if defined(HALFHOLE)
    // Transition potential
    Fock_half_hole(xcatom,lhsol,conv,dft,occa,occb,oldsol,grid,tol);
#elif defined(FULLHOLE)
    // Full core hole
    Fock_full_hole(xcatom,lhsol,conv,dft,occa,occb,oldsol,grid,tol,xch);

    // Unrestricted case
#elif defined(HF)
    Fock_UHF(lhsol,occa,occb,conv,oldsol,tol);
#elif defined(_ROHF)
    Fock_ROHF(lhsol,Nel_alpha,Nel_beta,conv,oldsol,tol);
#elif defined(DFT)
    Fock_UDFT(lhsol,occa,occb,conv,dft,oldsol,grid,tol);
#endif

#endif // End spin case
    nfock++;

    // Copy LHS Fock matrix to RHS
    rhsol=lhsol;

    // and diagonalize it to get the RHS density
#if defined(HALFHOLE)
    diagonalize_hch(rhsol);
#elif defined(FULLHOLE)
    diagonalize_fch(rhsol);
#elif defined(RESTRICTED)
    diagonalize(rhsol);
#else
    diagonalize(rhsol);
#endif

#ifdef RESTRICTED
    rhsol.P=form_density(rhsol.C,occs);
#else
    rhsol.Pa=form_density(rhsol.Ca,occa);
    rhsol.Pb=form_density(rhsol.Cb,occb);
#endif
    
    // Form the rhs fock operator
#ifdef RESTRICTED
    // Restricted case.
#if defined(HF)
    Fock_RHF(rhsol,occs,conv,sol,tol);
#elif defined(DFT)
    Fock_RDFT(rhsol,occs,conv,dft,sol,grid,tol);
#endif
#else
#if defined(HALFHOLE)
    // Transition potential
    Fock_half_hole(xcatom,rhsol,conv,dft,occa,occb,sol,grid,tol);
#elif defined(FULLHOLE)
    // Full core hole
    Fock_full_hole(xcatom,rhsol,conv,dft,occa,occb,sol,grid,tol,xch);

    // Unrestricted case
#elif defined(HF)
    Fock_UHF(rhsol,occa,occb,conv,sol,tol);
#elif defined(_ROHF)
    Fock_ROHF(rhsol,Nel_alpha,Nel_beta,conv,sol,tol);
#elif defined(DFT)
    Fock_UDFT(rhsol,occa,occb,conv,dft,sol,grid,tol);
#endif

#endif // End spin case
    nfock++;
    


    // Now determine optimal mixing factor. Golden ratio is
    const double tau=2.0/(1.0+sqrt(5.0));

    // Bracket is
    double a=0.0;
    double b=1.0;

#ifdef RESTRICTED
    rscf_t s1, s2;
    rscf_t s1ref, s2ref; 
#else
    uscf_t s1, s2;
    uscf_t s1ref, s2ref;
#endif

    // Fock operator will be F=a*F0+b*F1
    for(int is=1;is<=maxiter;is++) {
      Timer tstep;

      // The current best solution is
#ifdef RESTRICTED
      rscf_t isol=sol;
#else
      uscf_t isol=sol;
#endif

      // Compute trials 1 and 2
      double l1=a+(1-tau)*(b-a);
      double l2=a+tau*(b-a);

      // Do the Fock matrix averaging
#ifdef RESTRICTED
      s1.H=l1*rhsol.H+(1-l1)*lhsol.H;
      s2.H=l2*rhsol.H+(1-l2)*lhsol.H;
#else
      s1.Ha=l1*rhsol.Ha+(1-l1)*lhsol.Ha;
      s1.Hb=l1*rhsol.Hb+(1-l1)*lhsol.Hb;
      s2.Ha=l2*rhsol.Ha+(1-l2)*lhsol.Ha;
      s2.Hb=l2*rhsol.Hb+(1-l2)*lhsol.Hb;
#endif

      // Diagonalize the matrices
#if defined(HALFHOLE)
      diagonalize_hch(s1);
      diagonalize_hch(s2);
#elif defined(FULLHOLE)
      diagonalize_fch(s1);
      diagonalize_fch(s2);
#elif defined(RESTRICTED)
      diagonalize(s1);
      diagonalize(s2);
#else
      diagonalize(s1);
      diagonalize(s2);
#endif

      // And generate density matrices (for checking convergence)
#ifdef RESTRICTED
      s1.P=form_density(s1.C,occs);
      s2.P=form_density(s2.C,occs);
#else
      s1.Pa=form_density(s1.Ca,occa);
      s1.Pb=form_density(s1.Cb,occb);
      s1.P=s1.Pa+s1.Pb;

      s2.Pa=form_density(s2.Ca,occa);
      s2.Pb=form_density(s2.Cb,occb);
      s2.P=s2.Pa+s2.Pb;
#endif
      
      // Initialize references
      if(l1<0.5)
	s1ref=lhsol;
      else
	s1ref=rhsol;
      if(l2<0.5)
	s2ref=lhsol;
      else
	s2ref=rhsol;

      // and form the Fock matrices
#ifdef RESTRICTED
      // Restricted case.
#if defined(HF)
      Fock_RHF(s1,occs,conv,s1ref,tol);
      Fock_RHF(s2,occs,conv,s2ref,tol);
#elif defined(DFT)
      Fock_RDFT(s1,occs,conv,dft,s1ref,grid,tol);
      Fock_RDFT(s2,occs,conv,dft,s2ref,grid,tol);
#endif
#else
#if defined(HALFHOLE)
      // Transition potential
      Fock_half_hole(xcatom,s1,conv,dft,occa,occb,s1ref,grid,tol);
      Fock_half_hole(xcatom,s2,conv,dft,occa,occb,s2ref,grid,tol);
#elif defined(FULLHOLE)
      // Full core hole
      Fock_full_hole(xcatom,s1,conv,dft,occa,occb,s1ref,grid,tol,xch);
      Fock_full_hole(xcatom,s2,conv,dft,occa,occb,s2ref,grid,tol,xch);

      // Unrestricted case
#elif defined(HF)
      Fock_UHF(s1,occa,occb,conv,s1ref,tol);
      Fock_UHF(s2,occa,occb,conv,s2ref,tol);
#elif defined(_ROHF)
      Fock_ROHF(s1,Nel_alpha,Nel_beta,conv,s1ref,tol);
      Fock_ROHF(s2,Nel_alpha,Nel_beta,conv,s2ref,tol);
#elif defined(DFT)
      Fock_UDFT(s1,occa,occb,conv,dft,s1ref,grid,tol);
      Fock_UDFT(s2,occa,occb,conv,dft,s2ref,grid,tol);
#endif

#endif // End spin case
      nfock+=2;

      // Update best solution
      double Emin=std::min(std::min(lhsol.en.E,s1.en.E),std::min(s2.en.E,rhsol.en.E));
      if(lhsol.en.E==Emin)
	sol=lhsol;
      else if(s1.en.E==Emin)
	sol=s1;
      else if(s2.en.E==Emin)
	sol=s2;
      else
	sol=rhsol;

      // Check that we aren't sitting on the minimum
      double Ei=std::min(s1.en.E,s2.en.E);
      if(rhsol.en.E<Ei) {
	// Move left limit to right value
	a=l2;
	lhsol=s2;
      } else if(lhsol.en.E<Ei) {
        // Move right limit to left value.
        b=l1;
	rhsol=s1;
      } else if(s1.en.E<s2.en.E) {
        // Move right limit
        b=l2;
	rhsol=s2;
      } else if(s1.en.E>s2.en.E) {
        // Move left limit
        a=l1;
	lhsol=s1;
      } else { // E1==E2        // Move both limits
        a=l1;
	lhsol=s1;
        b=l2;
	rhsol=s2;
      }
      
      // Evaluate termination criteria
#ifdef RESTRICTED
      arma::mat deltaP=sol.P-isol.P;
#else
      // Compute change of polarized densities
      arma::mat deltaPa=sol.Pa-isol.Pa;
      arma::mat deltaPb=sol.Pb-isol.Pb;
#endif
      deltaE=sol.en.E-isol.en.E;
      
      // Compute dipole moment
      olddip=norm(dipmom);
      dipmom=dipole_moment(sol.P,*basisp);
      
      // Compute convergence criteria
#ifdef RESTRICTED
      maxdiff=max_abs(deltaP);
      rmsdiff=rms_norm(deltaP);
#else
      maxdiffa=max_abs(deltaPa);
      maxdiffb=max_abs(deltaPb);
      
      rmsdiffa=rms_norm(deltaPa);
      rmsdiffb=rms_norm(deltaPb);
      
      maxdiff=std::max(maxdiffa,maxdiffb);
      rmsdiff=std::max(rmsdiffa,rmsdiffb);
      //    rmsdiff=sqrt(rmsdiffa*rmsdiffa+rmsdiffb*rmsdiffb)/2.0;
#endif

      // Sparse output
      if(verbose) {
	fprintf(stderr,"%6i % 16.8f",is,sol.en.E);

	if(fabs(deltaE)<conv.deltaEmax)
	  fprintf(stderr," % 10.3e*",deltaE);
	else
	  fprintf(stderr," % 10.3e ",deltaE);

	if(rmsdiff<conv.deltaPrms)
	  fprintf(stderr," %9.3e*",rmsdiff);
	else
	  fprintf(stderr," %9.3e ",rmsdiff);

	if(maxdiff<conv.deltaPmax)
	  fprintf(stderr," %9.3e*",maxdiff);
	else
	  fprintf(stderr," %9.3e ",maxdiff);

	fprintf(stderr," %8.3f %10.3f\n",norm(dipmom),tstep.get());
	fflush(stderr);
      }

      if(verbose) {
	printf("Energies in current bracket\n\t% .10e\t% .10e\t% .10e\t% .10e\n",lhsol.en.E,s1.en.E,s2.en.E,rhsol.en.E);
	printf("Minimum energy change from last bracket %e.\n",deltaE);
	printf("Density change: %e RMS, %e max.\n\n",rmsdiff,maxdiff);
      }


      // Terminate iteration? Energy converged?
      //      if(fabs(deltaE)<conv.deltaEmax && maxdiff<conv.deltaPmax && rmsdiff<conv.deltaPrms)
      if(fabs(deltaE)<conv.deltaEmax)
	break;
      
      // Too small a section?
      if(fabs(b-a)<sqrt(DBL_EPSILON)*(fabs(l1)+fabs(l2)))
	break;
    }
    
    // Check convergence
#ifdef RESTRICTED
    arma::mat deltaP=sol.P-oldsol.P;
#else
    // Compute change of polarized densities
    arma::mat deltaPa=sol.Pa-oldsol.Pa;
    arma::mat deltaPb=sol.Pb-oldsol.Pb;
#endif
    deltaE=sol.en.E-oldsol.en.E;
    
    // Update tolerance
    if(!strictint)
      tol=std::min(std::min(fabs(deltaE)*1e-2,ROUGHTOL),tol);
    
    // Compute old dipole moment
    dipmom=dipole_moment(oldsol.P,*basisp);
    olddip=norm(dipmom);
    // and the new one
    dipmom=dipole_moment(sol.P,*basisp);
    
    // Compute convergence criteria
#ifdef RESTRICTED
    maxdiff=max_abs(deltaP);
    rmsdiff=rms_norm(deltaP);
#else
    maxdiffa=max_abs(deltaPa);
    maxdiffb=max_abs(deltaPb);
    
    rmsdiffa=rms_norm(deltaPa);
    rmsdiffb=rms_norm(deltaPb);
    
    maxdiff=std::max(maxdiffa,maxdiffb);
    rmsdiff=std::max(rmsdiffa,rmsdiffb);
    //    rmsdiff=sqrt(rmsdiffa*rmsdiffa+rmsdiffb*rmsdiffb)/2.0;
#endif

    // Sparse output
    if(verbose) {
      fprintf(stderr,"Change % 16.8f",sol.en.E);

      if(fabs(deltaE)<conv.deltaEmax)
	fprintf(stderr," % 10.3e*",deltaE);
      else
	fprintf(stderr," % 10.3e ",deltaE);

      if(rmsdiff<conv.deltaPrms)
	fprintf(stderr," %9.3e*",rmsdiff);
      else
	fprintf(stderr," %9.3e ",rmsdiff);

      if(maxdiff<conv.deltaPmax)
	fprintf(stderr," %9.3e*",maxdiff);
      else
	fprintf(stderr," %9.3e ",maxdiff);

      fprintf(stderr," %8.3f %10.3f\n\n",norm(dipmom),titer.get());
    }
    
    // Print out full status information
    if(verbose) {
      
#ifdef RESTRICTED
      print_E(sol.E,occs);
#else
      printf("alpha: ");
      print_E(sol.Ea,occa);
      printf("beta:  ");
      print_E(sol.Eb,occb);
#endif
      
      printf("\nDipole:\tx\t\ty\t\tz\t\tdipole change\n");
      printf("\t% 08.8f\t% 08.8f\t% 08.8f\t% e\n",dipmom(0),dipmom(1),dipmom(2),norm(dipmom)-olddip);
      
      printf("Energy:\telectronic\ttotal\t\tvirial\t\tenergy change\n");
      printf("\t% 08.8f\t% 08.8f\t% 08.8f\t% g\n",sol.en.Eel,sol.en.E,-sol.en.E/sol.en.Ekin,deltaE);
      
#ifdef DFT
      printf("\tkinetic\t\tnuclear\t\tCoulomb\t\tXC\n");
#else
      // No correlation in Hartree-Fock!
      printf("\tkinetic\t\tnuclear\t\tCoulomb\t\tExchange\n");
#endif
      printf("\t% 08.8f\t% 08.8f\t% 08.8f\t% 08.8f\n",sol.en.Ekin,sol.en.Enuca,sol.en.Ecoul,sol.en.Exc);
      
#ifdef RESTRICTED
      printf("Errors:\tMax dens\tRMS dens\n");
      printf("\t% e\t% e\n",maxdiff,rmsdiff);
#else
      printf("Errors:\tMax dens\tRMS dens\n");
      printf("alpha\t%e\t%e\n",maxdiffa,rmsdiffa);
      printf("beta\t%e\t%e\n",maxdiffb,rmsdiffb);
#endif
    }

    if(fabs(deltaE)<conv.deltaEmax && maxdiff<conv.deltaPmax && rmsdiff<conv.deltaPrms) {
      printf("\n ******* Convergence achieved ********\n");
      converged=true;
      break;
    }
    
    // Pad occupancies with zeros (needed e.g. in Casida routines)
#if !defined(RESTRICTED)
    std::vector<double> occar(occa), occbr(occb);
    while(occar.size()<Sinvh.n_cols)
      occar.push_back(0.0);
    while(occbr.size()<Sinvh.n_cols)
      occbr.push_back(0.0);
#else
    std::vector<double> occr(occs);
    while(occr.size()<Sinvh.n_cols)
      occr.push_back(0.0);
#endif

    // Write current matrices to checkpoint.
    // To use the file effectively, we keep it open for the whole shebang.
    chkptp->open();
    chkptp->write("P",sol.P);
    chkptp->write(sol.en);
#if !defined(RESTRICTED)
    chkptp->write("Ca",sol.Ca);
    chkptp->write("Cb",sol.Cb);

    chkptp->write("Ea",sol.Ea);
    chkptp->write("Eb",sol.Eb);

    chkptp->write("Pa",sol.Pa);
    chkptp->write("Pb",sol.Pb);

    chkptp->write("occa",occar);
    chkptp->write("occb",occbr);

    // Restricted
    chkptp->write("Restricted",0);
#else
    chkptp->write("C",sol.C);
    chkptp->write("E",sol.E);
    chkptp->write("occs",occr);
    // Unrestricted
    chkptp->write("Restricted",1);
#endif
    chkptp->write("Converged",converged);
    chkptp->close();

    if(converged)
      break;
  } // End SCF cycle
  
    // Compute dipole moment
  if(verbose) {
    arma::vec dp=dipole_moment(sol.P,*basisp);
    printf("Dipole moment is (%f,%f,%f) D, |mu|=%f D.\n",dp[0]/AUINDEBYE,dp[1]/AUINDEBYE,dp[2]/AUINDEBYE,norm(dp)/AUINDEBYE);
  }
  
  if(converged) {
    if(verbose) {
      std::string method=
#ifdef RESTRICTED
	"R"
#elif defined(_ROHF)
	"RO"
#else
	"U"
#endif
#ifdef DFT
	"DFT"
#else
	"HF"
#endif
	;

      printf("Solution of %s took %s.\n",method.c_str(),ttot.elapsed().c_str());
      fprintf(stderr,"%s converged in %s.\n\n",method.c_str(),ttot.elapsed().c_str());
    }
  } else {
    std::ostringstream oss;
    oss << "Error in function " << __FUNCTION__ << " (file " << __FILE__ << ", near line " << __LINE__ << "): SCF did not converge in "<<maxiter<<" iterations!\n";
    throw std::runtime_error(oss.str());
  }

#if defined(HALFHOLE) || defined(FULLHOLE)
  return ixc_orb;
#endif
}
