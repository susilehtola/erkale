/* Resticted case */
#if defined(RESTRICTED) && defined(DFT)
void SCF::RDFT_ls(rscf_t & sol, const std::vector<double> & occs, const convergence_t conv, const dft_t dft) const

#elif defined(RESTRICTED) && defined(HF)
  void SCF::RHF_ls(rscf_t & sol, const std::vector<double> & occs, const convergence_t conv) const

#elif defined(UNRESTRICTED) && defined(DFT)
  void SCF::UDFT_ls(uscf_t & sol, const std::vector<double> & occa, const std::vector<double> & occb, const convergence_t conv, const dft_t dft) const

#elif defined(UNRESTRICTED) && defined(HF)
  void SCF::UHF_ls(uscf_t & sol, const std::vector<double> & occa, const std::vector<double> & occb, const convergence_t conv) const
#elif defined(UNRESTRICTED) && defined(_ROHF)
void SCF::ROHF_ls(uscf_t & sol, int Nel_alpha, int Nel_beta, const convergence_t conv) const

#elif defined(DFT) && defined(FULLHOLE)
size_t XRSSCF::full_hole_ls(size_t xcatom, uscf_t & sol, convergence_t conv, dft_t dft, bool xch) const

#elif defined(DFT) && defined(HALFHOLE)
  size_t XRSSCF::half_hole_ls(size_t xcatom, uscf_t & sol, convergence_t conv, dft_t dft) const
#endif
{

  /// Mix densities instead of Fock matrices?
  //#define MIXDENSITY

  /// Formation of Fock matrix
#ifdef RESTRICTED
#if defined(HF)
#define form_fock(sol,ref) Fock_RHF(sol,occs,conv,ref,tol); nfock++;
#elif defined(DFT)
#define form_fock(sol,ref) Fock_RDFT(sol,occs,conv,dft,ref,grid,tol); nfock++;
#endif

#else
  // Unrestricted case: first core excited states

#if defined(HALFHOLE)
#define form_fock(sol,ref) Fock_half_hole(xcatom,sol,conv,dft,occa,occb,ref,grid,tol); nfock++;
#elif defined(FULLHOLE)
#define form_fock(sol,ref) Fock_full_hole(xcatom,sol,conv,dft,occa,occb,ref,grid,tol,xch); nfock++;

  // Conventional HF and DFT
#elif defined(HF)
#define form_fock(sol,ref) Fock_UHF(sol,occa,occb,conv,ref,tol); nfock++;
#elif defined(_ROHF)
#define form_fock(sol,ref) Fock_ROHF(sol,Nel_alpha,Nel_beta,conv,ref,tol); nfock++;
#elif defined(DFT)
#define form_fock(sol,ref) Fock_UDFT(sol,occa,occb,conv,dft,ref,grid,tol); nfock++;
#endif
#endif

  /// Diagonalization
#if defined(HALFHOLE)
#define diag(sol) diagonalize_hch(sol);
#elif defined(FULLHOLE)
#define diag(sol) diagonalize_fch(sol);
#else
#define diag(sol) diagonalize(sol);
#endif

  /// Density formation
#ifdef RESTRICTED
#define form_dens(sol) sol.P=form_density(sol.C,occs);
#else
#define form_dens(sol) sol.Pa=form_density(sol.Ca,occa); sol.Pb=form_density(sol.Cb,occb); sol.P=sol.Pa+sol.Pb;
#endif



#if defined(_ROHF)
  // Occupations
  std::vector<double> occa;
  std::vector<double> occb;

  if(basisp->get_Nnuc()==1) {
    occa=atomic_occupancy(Nel_alpha);
    occb=atomic_occupancy(Nel_beta);
  } else {
    occa=std::vector<double>(Nel_alpha,1.0);
    occb=std::vector<double>(Nel_beta,1.0);
  }

#elif ( defined(HALFHOLE) || defined(FULLHOLE) )
  // Occupation vector of spin up and spin down
  std::vector<double> occa;
  std::vector<double> occb;
#endif

  // Determine number of occupied states
#if !defined(HALFHOLE) && !defined(FULLHOLE)
#if defined(RESTRICTED)
  size_t nocc;
  for(nocc=occs.size()-1;nocc<occs.size();nocc--)
    if(occs[nocc]>0)
      break;
  nocc++;
#else
  size_t nocca;
  for(nocca=occa.size()-1;nocca<occa.size();nocca--)
    if(occa[nocca]>0)
      break;
  nocca++;
  
  size_t noccb;
  for(noccb=occb.size()-1;noccb<occb.size();noccb--)
    if(occb[noccb]>0)
      break;
  noccb++;
#endif
#endif


  Timer t;
  Timer ttot;

  // Dipole moment
  arma::vec dipmom;
  double olddip;

  // Tolerance for screening and screening efficiency
  double tol;

  // Determine tolerance to use
  if(strictint)
    tol=STRICTTOL;
  else
    tol=ROUGHTOL;

  // Change in energy from last iteration
  double deltaE=0;

  // Maximum and RMS differences of AO density matrix
  double rmsdiff=0.0, maxdiff=0.0;
#ifndef RESTRICTED
  double rmsdiffa=0.0, maxdiffa=0.0;
  double rmsdiffb=0.0, maxdiffb=0.0;
#endif

  if(verbose)
    printf("\n ******* Initialization of run ********\n");

#ifdef RESTRICTED
  if(sol.C.n_rows!=Nbf)
#else
    if(sol.Ca.n_rows!=Nbf || sol.Cb.n_rows!=Nbf)
#endif
      {

	if(guess!=COREGUESS)
	  throw std::runtime_error("No starting guess, and use of core guess disallowed!\n");
	
#ifdef RESTRICTED
	sol.H=Hcore;
#else
	sol.Ha=Hcore;
	sol.Hb=Hcore;
#endif

	// Diagonalize
	diag(sol);

	if(verbose)
	  printf("\nCore guess formed in %s.\n",t.elapsed().c_str());
	
      } else {
      // Got correctly sized input guess.
      
      if(verbose)
        printf("\nUsing input guess for orbitals.\n");
    }
  fflush(stdout);

  // Form the density matrix
  form_dens(sol);

#if defined(FULLHOLE) || defined(HALFHOLE)
  size_t ixc_orb=0;
#endif
  
#ifdef DFT
  // Fraction of exact exchange
  double kfrac=exact_exchange(dft.x_func);

  if(verbose) {
    if(kfrac!=0.0)
      printf("\nUsing hybrid exchange with % .3f of exact exchange.\n",kfrac*100);
    else
      printf("\nA pure exchange functional used, no exact exchange.\n");
  }

  DFTGrid grid(basisp,verbose,dft_lobatto);
#endif

  // Sparse output to stderr
  if(verbose) {
    fprintf(stderr,"Running ");
#if defined(RESTRICTED) || defined(_ROHF)
    fprintf(stderr,"restricted ");
#else
    fprintf(stderr,"unrestricted ");
#endif

#ifndef DFT
#ifdef _ROHF
    fprintf(stderr,"open-shell ");
#endif
    fprintf(stderr,"HF ");
#else
    if(dft.c_func>0) {
      // Correlation exists.
      fprintf(stderr,"%s-%s ",get_keyword(dft.x_func).c_str(),get_keyword(dft.c_func).c_str());
    } else
      fprintf(stderr,"%s ",get_keyword(dft.x_func).c_str());
#endif

    fprintf(stderr,"calculation");
    if(densityfit)
      fprintf(stderr," with density fitting");

#ifdef DFT
#if (defined(FULLHOLE) || defined(HALFHOLE))
    if(densityfit)
      fprintf(stderr," and ");
    else
      fprintf(stderr," with ");
#ifdef FULLHOLE
    fprintf(stderr,"full core hole");
    if(xch)
      fprintf(stderr," (XCH)");
#else // half hole
    fprintf(stderr,"half core hole");
#endif
#endif

#endif // end DFT clause
    fprintf(stderr," using line search of ");
#ifdef MIXDENSITY
    fprintf(stderr,"density");
#else
    fprintf(stderr,"Fock");
#endif
    fprintf(stderr," matrix.\n");
    fprintf(stderr,"%6s %16s %10s  %9s  %9s  %8s %10s\n","","E","dE","RMS dens","MAX dens","dip mom","titer (s)");
  }
  fflush(stdout);
  fflush(stderr);

  // Solution of last iteration
#ifdef RESTRICTED
  rscf_t oldsol;
#else
  uscf_t oldsol;
#endif

  bool converged=false;
  int nfock=0;

#ifdef DFT
  // Use the same grid in all iterations, otherwise convergence cannot be achieved
  {
    Timer tgrid;
#ifdef RESTRICTED
    // Form DFT quadrature grid
    grid.construct(sol.P,conv.deltaEmax,dft.x_func,dft.c_func);
#else
    // Form DFT quadrature grid
    grid.construct(sol.Pa,sol.Pb,conv.deltaEmax,dft.x_func,dft.c_func);
#endif
    fflush(stdout);
    
    if(verbose) {
      fprintf(stderr,"%-66s %10.3f\n","    DFT grid formation",tgrid.get());
      fflush(stderr);
      t.set();
    }
  }
#endif // ifdef DFT

  // The old bracket
  std::vector<double> oldbracket;

  // Loop:
  for(int iiter=1;iiter<=maxiter;iiter++) {
    Timer titer;
    
    if(verbose) {
      printf("\n ******* Iteration %4i ********\n",iiter);
      fprintf(stderr,"Iteration %i\n",iiter);
      fflush(stderr);
      fflush(stdout);
    }

    // Save solution
    oldsol=sol;

    // Solution matrix
#ifdef RESTRICTED
    std::vector<rscf_t> msol(4,sol); 
#else
    std::vector<uscf_t> msol(4,sol);
#endif

    // We have the LHS density, form the LHS Fock operator.
    form_fock(msol[0],sol);

    // Copy LHS Fock matrix to RHS
    msol[3]=msol[0];
    // and diagonalize it to get the RHS density
    diag(msol[3]);
    form_dens(msol[3]);
    // and then form the RHS Fock operator
    form_fock(msol[3],msol[0]);

    // Now determine optimal mixing factor. Golden ratio is ~ 0.618
    const double tau=2.0/(1.0+sqrt(5.0));

    // Bracket is
    std::vector<double> bracket(4);
    bracket[0]=0.0;
    bracket[3]=1.0;

    // Average Fock or density operator will be M=a*M_LHS+b*M_RHS.
    // 10 iterations refines the mixing factor to a precision of ~10^-6
    for(int is=1;is<=10;is++) {
      Timer tstep;

      // The current best solution is
#ifdef RESTRICTED
      rscf_t isol=sol;
#else
      uscf_t isol=sol;
#endif

      // Compute trials 1 and 2
      bracket[1]=bracket[0]+(1-tau)*(bracket[3]-bracket[0]);
      bracket[2]=bracket[0]+tau*(bracket[3]-bracket[0]);
      
      // Do the averaging
      for(int idx=1;idx<3;idx++) {

#ifdef MIXDENSITY
#ifdef RESTRICTED
	msol[idx].P=bracket[idx]*msol[3].P+(1-bracket[idx])*msol[0].P;
	// Purify, account for double occupancy
	msol[idx].P=2.0*purify_density_NO(msol[idx].P/2.0,msol[idx].C,S);
#else
	msol[idx].Pa=bracket[idx]*msol[3].Pa+(1-bracket[idx])*msol[0].Pa;
	msol[idx].Pb=bracket[idx]*msol[3].Pb+(1-bracket[idx])*msol[0].Pb;
	msol[idx].Pa=purify_density_NO(msol[idx].Pa,msol[idx].Ca,S);
	msol[idx].Pb=purify_density_NO(msol[idx].Pb,msol[idx].Cb,S);
#endif

#else // ifdef MIXDENSITY

#ifdef RESTRICTED
	msol[idx].H=bracket[idx]*msol[3].H+(1-bracket[idx])*msol[0].H;
#else
	msol[idx].Ha=bracket[idx]*msol[3].Ha+(1-bracket[idx])*msol[0].Ha;
	msol[idx].Hb=bracket[idx]*msol[3].Hb+(1-bracket[idx])*msol[0].Hb;
#endif
	// Form the density generated by the average Fock matrix
	diag(msol[idx]);
	// And generate density matrix (for checking convergence)
	form_dens(msol[idx]);

#endif // ifdef MIXDENSITY

	// Initialize reference
#ifdef RESTRICTED
	rscf_t ref;
#else
	uscf_t ref;
#endif

	if(fabs(bracket[idx]-bracket[0])<fabs(bracket[idx]-bracket[3]))
	  ref=msol[0];
	else
	  ref=msol[3];
	
	// and form the Fock matrix
	form_fock(msol[idx],ref);
      }
      
      // Sort the energies in increasing order
      std::vector<double> en;
      std::vector<int> enidx;
      bool added;
      do {
	added=false;
	// Find the next minimal energy in the array
	double Emin=DBL_MAX;
	int minind=-1;
	
	for(int idx=0;idx<4;idx++) {
	  if(msol[idx].en.E<Emin) {
	    // Check that the energy isn't already in the table
	    bool ok=true;
	    for(size_t j=0;j<en.size();j++)
	      if(en[j]==msol[idx].en.E)
		// Found the energy.
		ok=false;
	    
	    if(ok) {
	      // OK, update indices.
	      minind=idx;
	      Emin=msol[idx].en.E;
	    }
	  }
	}

	// Add the energy
	if(minind!=-1) {
	  added=true;
	  en.push_back(msol[minind].en.E);
	  enidx.push_back(minind);
	}
      } while(added);

      // Determine which indices to use
      int minind=enidx[0];
      int lowind=enidx[1];

      // Check if the interval changed or not.
      if( (minind==0 && lowind==3) || (minind==3 && lowind==0) )
	lowind=enidx[2];

      // Update the best solution?
      if(msol[minind].en.E!=sol.en.E) {
	isol=sol;
	sol=msol[minind];
      }
      
      // Form the new bracket
      std::vector<double> newbracket(4);
      newbracket[0]=bracket[lowind];
      newbracket[3]=bracket[minind];
      if(newbracket[3]<newbracket[0])
	std::swap(newbracket[3],newbracket[0]);

      // and update it
      oldbracket=bracket;
      bracket=newbracket;

      // Evaluate termination criteria
#ifdef RESTRICTED
      arma::mat deltaP=sol.P-isol.P;
#else
      // Compute change of polarized densities
      arma::mat deltaPa=sol.Pa-isol.Pa;
      arma::mat deltaPb=sol.Pb-isol.Pb;
#endif
      deltaE=sol.en.E-isol.en.E;
      
      // Compute dipole moment
      olddip=norm(dipmom);
      dipmom=dipole_moment(sol.P,*basisp);
      
      // Compute convergence criteria
#ifdef RESTRICTED
      maxdiff=max_abs(deltaP);
      rmsdiff=rms_norm(deltaP);
#else
      maxdiffa=max_abs(deltaPa);
      maxdiffb=max_abs(deltaPb);
      
      rmsdiffa=rms_norm(deltaPa);
      rmsdiffb=rms_norm(deltaPb);
      
      maxdiff=std::max(maxdiffa,maxdiffb);
      rmsdiff=std::max(rmsdiffa,rmsdiffb);
      //    rmsdiff=sqrt(rmsdiffa*rmsdiffa+rmsdiffb*rmsdiffb)/2.0;
#endif

      // Sparse output
      if(verbose) {
	fprintf(stderr,"%6i % 16.8f",is,sol.en.E);

	if(fabs(deltaE)<conv.deltaEmax)
	  fprintf(stderr," % 10.3e*",deltaE);
	else
	  fprintf(stderr," % 10.3e ",deltaE);

	if(rmsdiff<conv.deltaPrms)
	  fprintf(stderr," %9.3e*",rmsdiff);
	else
	  fprintf(stderr," %9.3e ",rmsdiff);

	if(maxdiff<conv.deltaPmax)
	  fprintf(stderr," %9.3e*",maxdiff);
	else
	  fprintf(stderr," %9.3e ",maxdiff);

	fprintf(stderr," %8.3f %10.3f\n",norm(dipmom),tstep.get());
	fflush(stderr);
      }

      if(verbose) {
	printf("Current bracket for mixing factor is\n\t% .10e\t% .10e\t% .10e\t% .10e\n",oldbracket[0],oldbracket[1],oldbracket[2],oldbracket[3]);
	printf("Energies in current bracket\n\t% .10e\t% .10e\t% .10e\t% .10e\n",msol[0].en.E,msol[1].en.E,msol[2].en.E,msol[3].en.E);
	printf("Minimum energy change from last bracket %e.\n",deltaE);
	printf("Density change: %e RMS, %e max.\n\n",rmsdiff,maxdiff);
      }


      // Terminate iteration?
      if(fabs(deltaE)<conv.deltaEmax && maxdiff<conv.deltaPmax && rmsdiff<conv.deltaPrms)
	//      if(fabs(deltaE)<conv.deltaEmax)
	break;
    }
    
    // Check convergence
#ifdef RESTRICTED
    arma::mat deltaP=sol.P-oldsol.P;
#else
    // Compute change of polarized densities
    arma::mat deltaPa=sol.Pa-oldsol.Pa;
    arma::mat deltaPb=sol.Pb-oldsol.Pb;
#endif
    deltaE=sol.en.E-oldsol.en.E;
    
    // Update tolerance
    if(!strictint)
      tol=std::min(std::min(fabs(deltaE)*1e-2,ROUGHTOL),tol);
    
    // Compute old dipole moment
    dipmom=dipole_moment(oldsol.P,*basisp);
    olddip=norm(dipmom);
    // and the new one
    dipmom=dipole_moment(sol.P,*basisp);
    
    // Compute convergence criteria
#ifdef RESTRICTED
    maxdiff=max_abs(deltaP);
    rmsdiff=rms_norm(deltaP);
#else
    maxdiffa=max_abs(deltaPa);
    maxdiffb=max_abs(deltaPb);
    
    rmsdiffa=rms_norm(deltaPa);
    rmsdiffb=rms_norm(deltaPb);
    
    maxdiff=std::max(maxdiffa,maxdiffb);
    rmsdiff=std::max(rmsdiffa,rmsdiffb);
    //    rmsdiff=sqrt(rmsdiffa*rmsdiffa+rmsdiffb*rmsdiffb)/2.0;
#endif

    // Sparse output
    if(verbose) {
      fprintf(stderr,"Change % 16.8f",sol.en.E);

      if(fabs(deltaE)<conv.deltaEmax)
	fprintf(stderr," % 10.3e*",deltaE);
      else
	fprintf(stderr," % 10.3e ",deltaE);

      if(rmsdiff<conv.deltaPrms)
	fprintf(stderr," %9.3e*",rmsdiff);
      else
	fprintf(stderr," %9.3e ",rmsdiff);

      if(maxdiff<conv.deltaPmax)
	fprintf(stderr," %9.3e*",maxdiff);
      else
	fprintf(stderr," %9.3e ",maxdiff);

      fprintf(stderr," %8.3f %10.3f\n\n",norm(dipmom),titer.get());
    }
    
    // Print out full status information
    if(verbose) {
      
#ifdef RESTRICTED
      print_E(sol.E,occs);
#else
      printf("alpha: ");
      print_E(sol.Ea,occa);
      printf("beta:  ");
      print_E(sol.Eb,occb);
#endif
      
      printf("\nDipole:\tx\t\ty\t\tz\t\tdipole change\n");
      printf("\t% 08.8f\t% 08.8f\t% 08.8f\t% e\n",dipmom(0),dipmom(1),dipmom(2),norm(dipmom)-olddip);
      
      printf("Energy:\telectronic\ttotal\t\tvirial\t\tenergy change\n");
      printf("\t% 08.8f\t% 08.8f\t% 08.8f\t% g\n",sol.en.Eel,sol.en.E,-sol.en.E/sol.en.Ekin,deltaE);
      
#ifdef DFT
      printf("\tkinetic\t\tnuclear\t\tCoulomb\t\tXC\n");
#else
      // No correlation in Hartree-Fock!
      printf("\tkinetic\t\tnuclear\t\tCoulomb\t\tExchange\n");
#endif
      printf("\t% 08.8f\t% 08.8f\t% 08.8f\t% 08.8f\n",sol.en.Ekin,sol.en.Enuca,sol.en.Ecoul,sol.en.Exc);
      
#ifdef RESTRICTED
      printf("Errors:\tMax dens\tRMS dens\n");
      printf("\t% e\t% e\n",maxdiff,rmsdiff);
#else
      printf("Errors:\tMax dens\tRMS dens\n");
      printf("alpha\t%e\t%e\n",maxdiffa,rmsdiffa);
      printf("beta\t%e\t%e\n",maxdiffb,rmsdiffb);
#endif
    }

    if(fabs(deltaE)<conv.deltaEmax && maxdiff<conv.deltaPmax && rmsdiff<conv.deltaPrms) {
      printf("\n ******* Convergence achieved ********\n");
      converged=true;
      break;
    }
    
    // Pad occupancies with zeros (needed e.g. in Casida routines)
#if !defined(RESTRICTED)
    std::vector<double> occar(occa), occbr(occb);
    while(occar.size()<Sinvh.n_cols)
      occar.push_back(0.0);
    while(occbr.size()<Sinvh.n_cols)
      occbr.push_back(0.0);
#else
    std::vector<double> occr(occs);
    while(occr.size()<Sinvh.n_cols)
      occr.push_back(0.0);
#endif

    // Write current matrices to checkpoint.
    // To use the file effectively, we keep it open for the whole shebang.
    chkptp->open();
    chkptp->write("P",sol.P);
    chkptp->write(sol.en);
#if !defined(RESTRICTED)
    chkptp->write("Ca",sol.Ca);
    chkptp->write("Cb",sol.Cb);

    chkptp->write("Ea",sol.Ea);
    chkptp->write("Eb",sol.Eb);

    chkptp->write("Pa",sol.Pa);
    chkptp->write("Pb",sol.Pb);

    chkptp->write("occa",occar);
    chkptp->write("occb",occbr);

    // Restricted
    chkptp->write("Restricted",0);
#else
    chkptp->write("C",sol.C);
    chkptp->write("E",sol.E);
    chkptp->write("occs",occr);
    // Unrestricted
    chkptp->write("Restricted",1);
#endif
    chkptp->write("Converged",converged);
    chkptp->close();

    if(converged)
      break;
  } // End SCF cycle
  
    // Compute dipole moment
  if(verbose) {
    arma::vec dp=dipole_moment(sol.P,*basisp);
    printf("Dipole moment is (%f,%f,%f) D, |mu|=%f D.\n",dp[0]/AUINDEBYE,dp[1]/AUINDEBYE,dp[2]/AUINDEBYE,norm(dp)/AUINDEBYE);
  }
  
  if(converged) {
    if(verbose) {
      std::string method=
#ifdef RESTRICTED
	"R"
#elif defined(_ROHF)
	"RO"
#else
	"U"
#endif
#ifdef DFT
	"DFT"
#else
	"HF"
#endif
	;

      printf("Solution of %s took %i Fock matrix rebuilds (%s).\n",method.c_str(),nfock,ttot.elapsed().c_str());
      fprintf(stderr,"Solution of %s required %i Fock matrix builds and took %s.\n\n",method.c_str(),nfock,ttot.elapsed().c_str());
    }
  } else {
    std::ostringstream oss;
    oss << "Error in function " << __FUNCTION__ << " (file " << __FILE__ << ", near line " << __LINE__ << "): SCF did not converge in "<<maxiter<<" iterations!\n";
    throw std::runtime_error(oss.str());
  }

#if defined(HALFHOLE) || defined(FULLHOLE)
  return ixc_orb;
#endif
}
