/*
 *                This source code is part of
 *
 *                     E  R  K  A  L  E
 *                             -
 *                       DFT from Hel
 *
 * Written by Susi Lehtola, 2010-2013
 * Copyright (c) 2010-2013, Susi Lehtola
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 */

#if defined(RESTRICTED) && defined(DFT)
void SCF::RDFT(rscf_t & sol, const std::vector<double> & occs, const convergence_t conv, const dft_t dft)

#elif defined(RESTRICTED) && defined(HF)
void SCF::RHF(rscf_t & sol, const std::vector<double> & occs, const convergence_t conv)

#elif defined(UNRESTRICTED) && defined(DFT)
void SCF::UDFT(uscf_t & sol, const std::vector<double> & occa, const std::vector<double> & occb, const convergence_t conv, const dft_t dft)

#elif defined(UNRESTRICTED) && defined(HF)
void SCF::UHF(uscf_t & sol, const std::vector<double> & occa, const std::vector<double> & occb, const convergence_t conv)

#elif defined(UNRESTRICTED) && defined(_ROHF)
void SCF::ROHF(uscf_t & sol, const std::vector<double> & occa, const std::vector<double> & occb, const convergence_t conv)

#elif defined(DFT) && defined(FULLHOLE)
size_t XRSSCF::full_hole(uscf_t & sol, convergence_t conv, dft_t dft, bool xch)

#elif defined(DFT) && defined(HALFHOLE)
size_t XRSSCF::half_hole(uscf_t & sol, convergence_t conv, dft_t dft)
#endif
{

  /// Formation of Fock matrix
#ifdef RESTRICTED
#if defined(HF)
#define form_fock(sol) Fock_RHF(sol,occs); nfock++;
#elif defined(DFT)
#define form_fock(sol) Fock_RDFT(sol,occs,dft,grid,nlgrid); nfock++;
#endif

#else
  // Unrestricted case: first core excited states

#if defined(HALFHOLE)
#define form_fock(sol) Fock_half_hole(sol,dft,occa,occb,grid,nlgrid); nfock++;
#elif defined(FULLHOLE)
#define form_fock(sol) Fock_full_hole(sol,dft,occa,occb,grid,nlgrid); nfock++;

  // Conventional HF and DFT
#elif defined(HF)
#define form_fock(sol) Fock_UHF(sol,occa,occb); nfock++;
#elif defined(_ROHF)
#define form_fock(sol) Fock_ROHF(sol,occa,occb); nfock++;
#elif defined(DFT)
#define form_fock(sol) Fock_UDFT(sol,occa,occb,dft,grid,nlgrid); nfock++;
#endif
#endif

  /// Find excited orbital
#if defined(FULLHOLE) || defined(HALFHOLE)
#define find_exc(sol) if(spin) {ixc_orb=find_excited_orb(*basisp,coreorb,sol.Cb,noccb);} else {ixc_orb=find_excited_orb(*basisp,coreorb,sol.Ca,nocca);}
#endif

  /// Occupancy update
#if defined(FULLHOLE)
#define upd_occa() if(spin) {occa=norm_occ(nocca);} else { if(xch) {occa=xch_occ(ixc_orb,nocca);} else {occa=fch_occ(ixc_orb,nocca);} }
#define upd_occb() if(!spin) {occb=norm_occ(noccb);} else { if(xch) {occb=xch_occ(ixc_orb,noccb);} else {occb=fch_occ(ixc_orb,noccb);} }
#elif defined(HALFHOLE)
#define upd_occa() if(spin) {occa=norm_occ(nocca);} else { occa=tp_occ(ixc_orb,nocca);}
#define upd_occb() if(!spin) {occb=norm_occ(noccb);} else { occb=tp_occ(ixc_orb,noccb);}
#endif

  /// Density formation
#ifdef RESTRICTED
#define form_dens(sol) form_density(sol,occs);
#else
#define form_dens_ur(sol) form_density(sol,occa,occb);

#if defined(HALFHOLE) || defined(FULLHOLE)
#define form_dens(sol) find_exc(sol); upd_occa(); upd_occb(); form_dens_ur(sol);
#else
#define form_dens(sol) form_dens_ur(sol)
#endif

#endif // ifdef RESTRICTED


#if ( defined(HALFHOLE) || defined(FULLHOLE) )
  // Occupation vector of spin up and spin down
  std::vector<double> occa;
  std::vector<double> occb;
#endif

  // Determine number of occupied states
#if !defined(HALFHOLE) && !defined(FULLHOLE)

#if defined(RESTRICTED)
  size_t nocc;
  for(nocc=occs.size()-1;nocc<occs.size();nocc--)
    if(occs[nocc]>0)
      break;
  nocc++;
#else
  size_t nocca;
  for(nocca=occa.size()-1;nocca<occa.size();nocca--)
    if(occa[nocca]>0)
      break;
  nocca++;

  size_t noccb;
  for(noccb=occb.size()-1;noccb<occb.size();noccb--)
    if(occb[noccb]>0)
      break;
  noccb++;
#endif
#endif

  int nfock=0;

  Timer t;
  Timer ttot;

  // DIIS error
  double diiserr=DBL_MAX;
  // Was DIIS succesful?
  bool diissucc=false;

  // Helper arrays
  arma::mat orbs;
  arma::mat Horth;

#ifdef RESTRICTED
  // DIIS iterator
  rDIIS diis(S,Sinvh,usediis,diis_c1,diiseps,diisthr,useadiis,verbose,diisorder);
  // Broyden
  Broyden broyd(verbose);

  // Coulomb and exchange matrices
  arma::mat J(Nbf,Nbf), K(Nbf,Nbf);
  J.zeros();
  K.zeros();
#else
  // DIIS iterator
  uDIIS diis(S,Sinvh,usediis,diis_c1,diiseps,diisthr,useadiis,verbose,diisorder);

  // Broyden
  Broyden broyd_sum(verbose);
  Broyden broyd_diff(verbose);

#endif

  // Dipole moment
  arma::vec dipmom;

  // Change in energy from last iteration
  double deltaE=0;

  // Maximum and RMS differences of AO density matrix
  double rmsdiff=0.0, maxdiff=0.0;
#ifndef RESTRICTED
  double rmsdiffa=0.0, maxdiffa=0.0;
  double rmsdiffb=0.0, maxdiffb=0.0;
#endif

#ifdef RESTRICTED
  if(sol.C.n_rows!=Nbf)
#else
    if(sol.Ca.n_rows!=Nbf || sol.Cb.n_rows!=Nbf)
#endif
      {
	throw std::runtime_error("No starting guess provided for SCF solver!\n");
      }

#if defined(FULLHOLE) || defined(HALFHOLE)
  size_t ixc_orb=0;
#endif

  // Form the density matrix
  form_dens(sol);

  // Print orbital energies
  if(verbose) {
#ifdef RESTRICTED
    print_E(sol.E,occs,false);
#else
    printf("alpha: ");
    print_E(sol.Ea,occa,false);
    printf("beta:  ");
    print_E(sol.Eb,occb,false);
#endif
    fflush(stdout);
  }

#ifdef DFT
  // Range separation constants
  double omega, kfull, kshort;
  range_separation(dft.x_func,omega,kfull,kshort);

  if(verbose) {
    if(omega!=0.0) {
      printf("\nUsing range separated exchange with range separation constant omega = % .3f.\n",omega);
      printf("Using % .3f %% short range and % .3f %% long range exchange.\n",(kfull+kshort)*100,kfull*100);
    } else if(kfull!=0.0)
      printf("\nUsing hybrid exchange with % .3f %% of exact exchange.\n",kfull*100);
    else
      printf("\nA pure exchange functional used, no exact exchange.\n");
  }

  // Evaluators for range separated part
  if(omega!=0.0) {
    if(!direct) {
      bool fill;
      if(!tab_rs.get_N()) {
	fill=true;
      } else {
	double o, kl, ks;
	tab_rs.get_range_separation(o,kl,ks);
	fill=(!(o==omega));
      }
      if(fill) {
	tab_rs.set_range_separation(omega,0.0,1.0);
	if(verbose) {
	  printf("Computing short-range repulsion integrals ... ");
	  fflush(stdout);
	  t.set();
	}
	size_t Npairs=tab_rs.fill(basisp,intthr);
	if(verbose) {
	  printf("done (%s)\n",t.elapsed().c_str());
	  printf("%i short-range shell pairs are significant.\n",(int) Npairs);
	}
      }
    } else {
      scr_rs.set_range_separation(omega,0.0,1.0);
      if(verbose) {
	printf("Computing short-range screening matrix ... ");
	fflush(stdout);
	t.set();
      }
      size_t Npairs=scr_rs.fill(basisp,intthr);
      
      if(verbose) {
	printf("done (%s)\n",t.elapsed().c_str());
	printf("%i short-range shell pairs are significant.\n",(int) Npairs);
      }
    }
  }

  DFTGrid grid(basisp,verbose,dft.lobatto);
  DFTGrid nlgrid(basisp,verbose,dft.lobatto);
#endif


  // Sparse output to stderr
  if(verbose) {
    fprintf(stderr,"Running ");
#if defined(RESTRICTED)
    fprintf(stderr,"restricted ");
#else
# if defined(_ROHF)
    fprintf(stderr,"restricted open-shell ");
#else
#if defined(UNRESTRICTED)
    fprintf(stderr,"unrestricted ");
#endif
#endif
#endif

#ifndef DFT
    fprintf(stderr,"HF ");
#else
    if(dft.c_func>0) {
      // Correlation exists.
      fprintf(stderr,"%s-%s ",get_keyword(dft.x_func).c_str(),get_keyword(dft.c_func).c_str());
    } else
      fprintf(stderr,"%s ",get_keyword(dft.x_func).c_str());
#endif

    fprintf(stderr,"calculation");
    if(densityfit) {
      fprintf(stderr," with density fitting");
    }

#ifdef DFT
#if (defined(FULLHOLE) || defined(HALFHOLE))
    if(densityfit)
      fprintf(stderr," and ");
    else
      fprintf(stderr," with ");
#ifdef FULLHOLE
    fprintf(stderr,"full core hole");
    if(xch)
      fprintf(stderr," (XCH)");
#else // half hole
    fprintf(stderr,"half core hole");
#endif
#endif

#endif // end DFT clause
    fprintf(stderr,".\n%4s %16s %10s  %9s  %9s  %9s %10s\n","iter","E","dE","RMS dens","MAX dens","DIIS err","titer (s)");
  }
  fflush(stdout);

#ifdef DFT
  if(dft.x_func>0 || dft.c_func>0) {
    if(dft.adaptive) {
#ifdef RESTRICTED
      // Form DFT quadrature grid
      grid.construct(sol.P,dft.gridtol,dft.x_func,dft.c_func);
#else
      // Form DFT quadrature grid
      grid.construct(sol.Pa,sol.Pb,dft.gridtol,dft.x_func,dft.c_func);
#endif
    } else {
      // Fixed size grid
      grid.construct(dft.nrad,dft.lmax,dft.x_func,dft.c_func,strictint);
      // Nonlocal grid?
      if(dft.nl)
	nlgrid.construct(dft.nlnrad,dft.nllmax,true,false,strictint,true);
    }

    if(verbose) {
      fflush(stdout);
      fprintf(stderr,"%-65s %10.3f\n","    DFT grid formation",t.get());
    }
  }
#endif // DFT

  // Has calculation been converged?
  bool converged=false;
  // How many consecutive iterations have seemed converged
  int convd=0;

  // Solution of last iteration
#ifdef RESTRICTED
  rscf_t oldsol;
#else
  uscf_t oldsol;
#endif
  oldsol.en.E=0.0;

  // Pad occupancies with zeros (needed e.g. in Casida routines)
#if !defined(RESTRICTED)
  std::vector<double> occar(occa), occbr(occb);
  while(occar.size()<Sinvh.n_cols)
    occar.push_back(0.0);
  while(occbr.size()<Sinvh.n_cols)
    occbr.push_back(0.0);
#else
  std::vector<double> occr(occs);
  while(occr.size()<Sinvh.n_cols)
    occr.push_back(0.0);
#endif

  // Write current matrices to checkpoint.
  // To use the file effectively, we keep it open for the whole shebang.
  chkptp->open();
  chkptp->write("tol",intthr);
  chkptp->write("P",sol.P);
  chkptp->write("S",S);
  chkptp->write("Sinvh",Sinvh);
  chkptp->write(sol.en);
#if !defined(RESTRICTED)
  chkptp->write("Ca",sol.Ca);
  chkptp->write("Cb",sol.Cb);

  chkptp->write("Ea",sol.Ea);
  chkptp->write("Eb",sol.Eb);

  chkptp->write("Pa",sol.Pa);
  chkptp->write("Pb",sol.Pb);

  chkptp->write("occa",occar);
  chkptp->write("occb",occbr);

  // Restricted
  chkptp->write("Restricted",0);
#else
  chkptp->write("C",sol.C);
  chkptp->write("E",sol.E);
  chkptp->write("occs",occr);
  // Unrestricted
  chkptp->write("Restricted",1);
#endif
  chkptp->write("Converged",converged);
  chkptp->close();

  // Loop:
  int iiter=1;
  
  while(iiter<=maxiter) {
    Timer titer;

    if(verbose)
      printf("\n ******* Iteration %4i ********\n",iiter);

    // Form the Fock operator.
    form_fock(sol);

    // Compute change of energy
    deltaE=sol.en.E-oldsol.en.E;

#ifdef RESTRICTED
    // Update DIIS stack of matrices
    diis.update(sol.H,sol.P,sol.en.E,diiserr);
#else
    // Update DIIS stacks of matrices
    diis.update(sol.Ha,sol.Hb,sol.Pa,sol.Pb,sol.en.E,diiserr);
#endif

    if(iiter>1 && usebroyden) {
#ifdef RESTRICTED
      // Update Broyden mixer
      broyd.push_x(MatToVec(oldsol.H));
      broyd.push_f(MatToVec(oldsol.H-sol.H));
#else
      // Compute sum and difference
      arma::mat Hs=sol.Ha+sol.Hb;
      arma::mat Hd=sol.Ha-sol.Hb;

      arma::mat Hsold=oldsol.Ha+oldsol.Hb;
      arma::mat Hdold=oldsol.Ha-oldsol.Hb;

      // Update Broyden mixers
      broyd_sum.push_x(MatToVec(Hsold));
      broyd_sum.push_f(MatToVec(Hsold-Hs));

      broyd_diff.push_x(MatToVec(Hdold));
      broyd_diff.push_f(MatToVec(Hdold-Hd));
#endif
    }

    // Solve DIIS
    try {
#ifdef RESTRICTED
      // Solve new matrix
      diis.solve_F(sol.H);
#else
      // Solve new matrices
      diis.solve_F(sol.Ha,sol.Hb);
#endif
      diissucc=true;
    } catch(std::runtime_error) {
      diissucc=false;
    }

    // Perform Broyden interpolation
    if(usebroyden && !diissucc && iiter>1) {
      
      if(verbose) {
	printf("Performing Broyden interpolation of Fock operator ... ");
	fflush(stdout);
	t.set();
      }

#ifdef RESTRICTED
      // Update Hamiltonian
      sol.H=VecToMat(broyd.update_x(),Nbf,Nbf);
#else
      arma::mat Hs=VecToMat(broyd_sum.update_x(),Nbf,Nbf);
      arma::mat Hd=VecToMat(broyd_diff.update_x(),Nbf,Nbf);

      // Update Hamiltonians
      sol.Ha=0.5*(Hs+Hd);
      sol.Hb=0.5*(Hs-Hd);
#endif

      if(verbose)
	printf("done (%s)\n",t.elapsed().c_str());
    }

    // Save old solution
    oldsol=sol;

    if(linesearch) {
      // Do line search in the level shift to find the update

      // LH level shift
      double lmu=0.0;
      // RH level shift;
      const double rmuin=0.5;
      double rmu=rmuin;

      bool mufound=false;

      // Solutions
#ifdef RESTRICTED
      rscf_t lhsol(sol), oldrhsol, rhsol(sol);
      const rscf_t refsol(sol);
#else
      uscf_t lhsol(sol), oldrhsol, rhsol(sol);
      const uscf_t refsol(sol);
#endif
      // Form LH solution - no level shift
      diagonalize(S,Sinvh,lhsol);
      form_dens(lhsol);
      form_fock(lhsol);
      diagonalize(S,Sinvh,lhsol);

      if(verbose) {
	printf("\nLine search for level shift\n");
	printf("\t%e\t%e\n",lmu,lhsol.en.E);
      }

      double minE=lhsol.en.E;

      // Find RH level shift
      while(true) {
	// Store old RH solution
	oldrhsol=rhsol;

#ifdef RESTRICTED
	rhsol.H=sol.H-rmu*S*sol.P*S;
#else
	rhsol.Ha=sol.Ha-rmu*S*sol.Pa*S;
	rhsol.Hb=sol.Hb-rmu*S*sol.Pb*S;
#endif
	diagonalize(S,Sinvh,rhsol);
	form_dens(rhsol);
	form_fock(rhsol);

	diagonalize(S,Sinvh,rhsol);

	if(verbose) {
	  printf("\t%e\t%e\t%e\n",rmu,rhsol.en.E,rhsol.en.E-lhsol.en.E);
	  fflush(stdout);
	}

	if(fabs(rhsol.en.E-lhsol.en.E)<conv.deltaEmax) {
	  sol=lhsol;
	  mufound=true;
	  break;
	}


	if(rhsol.en.E<minE) {
	  minE=rhsol.en.E;
	  // Update LH shift and solution
	  if(rmu!=rmuin) {
	    lhsol=oldrhsol;
	    lmu=rmu/2.0;
	  }
	  // and increase RH shift
	  rmu*=2.0;
	} else
	  break;
      }

      double Emin0=std::min(lhsol.en.E,rhsol.en.E);

      double oldE=0.0;

      // Use golden section search to find minimum
      const double tau=(sqrt(5.0)-1.0)/2.0;

      // Compute trials 1 and 2?
      bool comp1=true;
      bool comp2=true;

#ifdef RESTRICTED
      rscf_t sol1(sol), sol2(sol);
#else
      uscf_t sol1(sol), sol2(sol);
#endif

      if(!mufound)
	for(int imu=0;imu<10;imu++) {
	  // Compute new trials
	  double mu1=lmu+(1-tau)*(rmu-lmu);
	  double mu2=lmu+tau*(rmu-lmu);

	  // Do level shifts
#ifdef RESTRICTED
	  if(comp1)
	    sol1.H=refsol.H-mu1*S*refsol.P*S;
	  if(comp2)
	    sol2.H=refsol.H-mu2*S*refsol.P*S;
#else
	  if(comp1) {
	    sol1.Ha=refsol.Ha-mu1*S*refsol.Pa*S;
	    sol1.Hb=refsol.Hb-mu1*S*refsol.Pb*S;
	  }
	  if(comp2) {
	    sol2.Ha=refsol.Ha-mu2*S*refsol.Pa*S;
	    sol2.Hb=refsol.Hb-mu2*S*refsol.Pb*S;
	  }
#endif

	  // Compute energies
	  if(comp1) {
	    diagonalize(S,Sinvh,sol1);
	    form_dens(sol1);
	    form_fock(sol1);
	    diagonalize(S,Sinvh,sol1);
	    if(verbose) {
	      printf("\t%e\t%e\t%e\n",mu1,sol1.en.E,sol1.en.E-Emin0);
	      fflush(stdout);
	    }
	  }

	  if(comp2) {
	    diagonalize(S,Sinvh,sol2);
	    form_dens(sol2);
	    form_fock(sol2);
	    diagonalize(S,Sinvh,sol2);
	    if(verbose) {
	      printf("\t%e\t%e\t%e\n",mu2,sol2.en.E,sol2.en.E-Emin0);
	      fflush(stdout);
	    }
	  }

	  /*
	    fprintf(stderr,"mu: %e %e %e %e\n",lmu,mu1,mu2,rmu);
	    fprintf(stderr,"E: %e %e %e %e\n",lhsol.en.E,sol1.en.E,sol2.en.E,rhsol.en.E);
	  */

	  // Choose what to do
	  minE=std::min(std::min(lhsol.en.E,rhsol.en.E),std::min(sol1.en.E,sol2.en.E));

	  if(minE==lhsol.en.E) {
	    // probably converged
	    sol=lhsol;
	    break;
	  } else if(minE==rhsol.en.E) {
	    // probably converged
	    sol=rhsol;
	    break;
	  } else if(minE==sol1.en.E) {
	    // Move right limit closer
	    rmu=mu2;
	    rhsol=sol2;

	    // New solution 2 is old solution 1
	    sol2=sol1;
	    comp2=false;
	    comp1=true;

	    oldE=sol.en.E;
	    sol=sol1;
	  } else { // minE==sol2.en.E
	    // Move left limit closer
	    lmu=mu1;
	    lhsol=sol1;

	    // New solution 1 is old solution 2
	    sol1=sol2;
	    comp1=false;
	    comp2=true;

	    oldE=sol.en.E;
	    sol=sol2;
	  }

	  // Check convergence
	  if(oldE-sol.en.E<conv.deltaEmax)
	    break;

	}
    } else if(usetrrh) {

      // Solve FC=ESC
      if(verbose) {
	printf("\nSolving TRRH equations.\n");
	fflush(stdout);
	t.set();
      }

#ifdef RESTRICTED
      arma::mat Cnew;
      arma::vec Enew;
      TRRH_update(sol.H,sol.C,S,Cnew,Enew,nocc,shift,verbose);

      // Update solution
      sol.C=Cnew;
      sol.E=Enew;

      // Check orthonormality of orbitals
      check_orth(sol.C,S,false);
#else
      arma::mat Canew;
      arma::vec Eanew;
      TRRH_update(sol.Ha,sol.Ca,S,Canew,Eanew,nocca,shift,verbose);

      arma::mat Cbnew;
      arma::vec Ebnew;
      TRRH_update(sol.Hb,sol.Cb,S,Cbnew,Ebnew,noccb,shift,verbose);

      // Update solutions
      sol.Ca=Canew;
      sol.Cb=Cbnew;

      sol.Ea=Eanew;
      sol.Eb=Ebnew;

      // Check orthonormality of orbitals
      check_orth(sol.Ca,S,false);
      check_orth(sol.Cb,S,false);
#endif

      if(verbose)
	printf("TRRH solved in %s.\n\n",t.elapsed().c_str());

    } else {

      // Solve FC=ESC
      if(verbose) {
	if(shift==0.0)
	  printf("\nSolving SCF equations ... ");
	else
	  printf("\nSolving SCF equations with level shift %.3f ... ",shift);
	fflush(stdout);
	t.set();
      }

      // Do the diagonalization
      diagonalize(S,Sinvh,sol,shift);

      if(verbose)
	printf("done (%s)\n",t.elapsed().c_str());
    }

    // Form new density matrix
    form_dens(sol);

    // Change-of-density matrices
    arma::mat deltaP=sol.P-oldsol.P;
#ifndef RESTRICTED
    arma::mat deltaPa=sol.Pa-oldsol.Pa;
    arma::mat deltaPb=sol.Pb-oldsol.Pb;
#endif

    // Compute dipole moment
    dipmom=dipole_moment(sol.P,*basisp);

    // Compute convergence criteria
    maxdiff=max_abs(deltaP/2.0);
    rmsdiff=rms_norm(deltaP/2.0);

    // Convergence checked against
    double maxdiff_cvd(maxdiff);
    double rmsdiff_cvd(maxdiff);
    
#ifndef RESTRICTED
    maxdiffa=max_abs(deltaPa);
    maxdiffb=max_abs(deltaPb);

    rmsdiffa=rms_norm(deltaPa);
    rmsdiffb=rms_norm(deltaPb);

    maxdiff_cvd=std::max(maxdiffa,maxdiffb);
    rmsdiff_cvd=std::max(rmsdiffa,rmsdiffb);
#endif

    // Print out status information
    if(verbose) {
      printf("\n");
      printf("%-30s: % e\n","DIIS error",diiserr);
      printf("%-30s: % e\n","Energy change",deltaE);
      printf("%-30s: % e\n","Max total density change",maxdiff);
      printf("%-30s: % e\n","Max rms   density change",rmsdiff);
#ifndef RESTRICTED
      printf("%-30s: % e\n","Max total alpha density change",maxdiffa);
      printf("%-30s: % e\n","Max rms   alpha density change",rmsdiffa);
      printf("%-30s: % e\n","Max total beta  density change",maxdiffb);
      printf("%-30s: % e\n","Max rms   beta  density change",rmsdiffb);
#endif
      printf("Dipole mu = (% 08.8f, % 08.8f, % 08.8f) D\n",dipmom(0)/AUINDEBYE,dipmom(1)/AUINDEBYE,dipmom(2)/AUINDEBYE);
      
      printf("\nIteration took %s.\n",titer.elapsed().c_str());
      fflush(stdout);
    }

    // Sparse output
    if(verbose) {
      fprintf(stderr,"%4i % 16.8f",iiter,sol.en.E);

      if(fabs(deltaE)<conv.deltaEmax)
	fprintf(stderr," % 10.3e*",deltaE);
      else
	fprintf(stderr," % 10.3e ",deltaE);

      if(rmsdiff_cvd<conv.deltaPrms)
	fprintf(stderr," %9.3e*",rmsdiff_cvd);
      else
	fprintf(stderr," %9.3e ",rmsdiff_cvd);

      if(maxdiff_cvd<conv.deltaPmax)
	fprintf(stderr," %9.3e*",maxdiff_cvd);
      else
	fprintf(stderr," %9.3e ",maxdiff_cvd);

      fprintf(stderr," %9.3e %10.3f\n",diiserr,titer.get());
    }

    if(fabs(deltaE)<=conv.deltaEmax && maxdiff_cvd<=conv.deltaPmax && rmsdiff_cvd<=conv.deltaPrms) {
      // Increment amount of converged iterations
      convd++;

      if(convd>=2) {
	converged=true;

	if(verbose)
	  printf("\n ******* Convergence achieved ********\n");
      }
    } else {
      // Reset number of consecutive converged iterations
      convd=0;
    }

    // Write current matrices to checkpoint.
    // To use the file effectively, we keep it open for the whole shebang.
    chkptp->open();
    chkptp->write("P",sol.P);
    chkptp->write("S",S);
    chkptp->write("Sinvh",Sinvh);
    chkptp->write(sol.en);
#if !defined(RESTRICTED)
    chkptp->write("Ca",sol.Ca);
    chkptp->write("Cb",sol.Cb);

    chkptp->write("Ea",sol.Ea);
    chkptp->write("Eb",sol.Eb);

    chkptp->write("Ha",sol.Ha);
    chkptp->write("Hb",sol.Hb);

    chkptp->write("Pa",sol.Pa);
    chkptp->write("Pb",sol.Pb);

    chkptp->write("occa",occar);
    chkptp->write("occb",occbr);

    // Restricted
    chkptp->write("Restricted",0);
#else
    chkptp->write("C",sol.C);
    chkptp->write("E",sol.E);
    chkptp->write("H",sol.H);
    chkptp->write("occs",occr);
    // Unrestricted
    chkptp->write("Restricted",1);
#endif
    chkptp->write("Converged",converged);
    chkptp->close();

    // Check convergence
    if(converged)
      break;

    iiter++;
  } // End SCF cycle

  if(verbose) {

    if(converged) {
      std::string method=
#ifdef RESTRICTED
	"R"
#elif defined(_ROHF)
	"RO"
#else
	"U"
#endif
#ifdef DFT
	"DFT"
#else
	"HF"
#endif
	;
      
      printf("Solution of %s took %s.\n",method.c_str(),ttot.elapsed().c_str());
      fprintf(stderr,"%s converged in %s.\n",method.c_str(),ttot.elapsed().c_str());

      if(linesearch) {
	printf("Fock matrix was built %i times.\n",nfock);
	fprintf(stderr,"Fock matrix was built %i times.\n",nfock);
      }
    }

    // Print total energy and its components
    printf("\n");
    printf("%-21s energy: % .16e\n","Kinetic",sol.en.Ekin);
    printf("%-21s energy: % .16e\n","Nuclear attraction",sol.en.Enuca);
    printf("%-21s energy: % .16e\n","Total one-electron",sol.en.Eone);
    printf("%-21s energy: % .16e\n","Nuclear repulsion",sol.en.Enucr);
    printf("%-21s energy: % .16e\n","Coulomb",sol.en.Ecoul);
#ifndef DFT
    printf("%-21s energy: % .16e\n","Exchange",sol.en.Exc);
#else
    printf("%-21s energy: % .16e\n","Exchange-correlation",sol.en.Exc);
    printf("%-21s energy: % .16e\n","Non-local correlation",sol.en.Enl);
    if(sol.en.Eeff)
      printf("%-21s energy: % .16e\n","SIC",sol.en.Eeff);
#endif
    printf("-----------------------------------------------------\n");
    printf("%28s: % .16e\n","Total energy",sol.en.E);
    printf("%28s: % .16e\n","Virial factor",-sol.en.E/sol.en.Ekin);

    printf("\nDipole mu = (% 08.8f, % 08.8f, % 08.8f) D\n",dipmom(0)/AUINDEBYE,dipmom(1)/AUINDEBYE,dipmom(2)/AUINDEBYE);

    printf("\n");
    // Print orbital energies
#ifdef RESTRICTED
    print_E(sol.E,occs,true);
#else
    printf("alpha: ");
    print_E(sol.Ea,occa,true);
    printf("beta:  ");
    print_E(sol.Eb,occb,true);
#endif
  }
  
  if(converged) {
    if(doforce) {
      arma::vec f;
#if defined(RESTRICTED) && defined(HF)
      f=force_RHF(sol,occs,intthr);
#endif
#if defined(UNRESTRICTED) && defined(HF)
      f=force_UHF(sol,occa,occb,intthr);
#endif
#if defined(RESTRICTED) && defined(DFT)
      f=force_RDFT(sol,occs,dft,grid,nlgrid,intthr);
#endif
#if defined(UNRESTRICTED) && defined(DFT)
      f=force_UDFT(sol,occa,occb,dft,grid,nlgrid,intthr);
#endif
#if defined(_ROHF) || defined(FULLHOLE) || defined(HALFHOLE)
      ERROR_INFO();
      throw std::runtime_error("Forces not supported for this method.\n");
#endif

      chkptp->write("Force",f);
    }

  } else {
    std::ostringstream oss;
    oss << "Error in function " << __FUNCTION__ << " (file " << __FILE__ << ", near line " << __LINE__ << "): SCF did not converge in "<<maxiter<<" iterations!\n";
    throw std::runtime_error(oss.str());
  }

#if defined(HALFHOLE) || defined(FULLHOLE)
  return ixc_orb;
#endif
}
