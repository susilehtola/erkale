/* Restricted case */
#if defined(RESTRICTED) && defined(DFT)
void SCF::RDFT(rscf_t & sol, const std::vector<double> & occs, const convergence_t conv, const dft_t dft) const

#elif defined(RESTRICTED) && defined(HF)
void SCF::RHF(rscf_t & sol, const std::vector<double> & occs, const convergence_t conv) const

#elif defined(UNRESTRICTED) && defined(DFT)
void SCF::UDFT(uscf_t & sol, const std::vector<double> & occa, const std::vector<double> & occb, const convergence_t conv, const dft_t dft) const

#elif defined(UNRESTRICTED) && defined(HF)
void SCF::UHF(uscf_t & sol, const std::vector<double> & occa, const std::vector<double> & occb, const convergence_t conv) const

#elif defined(UNRESTRICTED) && defined(_ROHF)
void SCF::ROHF(uscf_t & sol, int Nel_alpha, int Nel_beta, const convergence_t conv) const

#elif defined(DFT) && defined(FULLHOLE)
size_t XRSSCF::full_hole(size_t xcatom, uscf_t & sol, convergence_t conv, dft_t dft) const

#elif defined(DFT) && defined(HALFHOLE)
size_t XRSSCF::half_hole(size_t xcatom, uscf_t & sol, convergence_t conv, dft_t dft) const
#endif
{

#if defined(UNRESTRICTED) && defined(_ROHF)
  // Occupations
  std::vector<double> occa(Nel_alpha,1.0);
  std::vector<double> occb(Nel_beta,1.0);
#elif ( defined(HALFHOLE) || defined(FULLHOLE) )
  // Occupation vector of spin up and spin down
  std::vector<double> occa;
  std::vector<double> occb;
#endif

  Timer t;
  Timer ttot;

  // DIIS error
  double diiserr;
#ifndef RESTRICTED
  double diiserra, diiserrb;
#endif
  // Was DIIS succesful?
  bool diissucc=0;

  // Helper arrays
  arma::mat orbs;
  arma::mat Horth;


#ifdef RESTRICTED
  // DIIS iterator
  DIIS diis(S,diisorder);

  // ADIIS
  ADIIS adiis;
  // Broyden
  Broyden broyd(Nbf*Nbf,verbose);

  // Coulomb and exchange matrices
  arma::mat J(Nbf,Nbf), K(Nbf,Nbf);
  J.zeros();
  K.zeros();

  // Change of density matrix from last iteration
  arma::mat deltaP(Nbf,Nbf);

  // Hamiltonian of last iteration
  arma::mat Hold(Nbf,Nbf);
  Hold.zeros();
#else
  // DIIS iterator
  DIIS diisa(S,diisorder);
  DIIS diisb(S,diisorder);

  // ADIIS
  ADIIS adiisa;
  ADIIS adiisb;

  // Broyden
  Broyden broyd_sum(Nbf*Nbf,verbose);
  Broyden broyd_diff(Nbf*Nbf,verbose);

  // Coulomb and exchange matrices
  arma::mat J(Nbf,Nbf);
  J.zeros();

  arma::mat Ka(Nbf,Nbf);
  arma::mat Kb(Nbf,Nbf);
  Ka.zeros();
  Kb.zeros();

  // Density matrix
  arma::mat deltaP(Nbf,Nbf);
  arma::mat deltaPa(Nbf,Nbf);
  arma::mat deltaPb(Nbf,Nbf);
  deltaPa.zeros();
  deltaPb.zeros();

  // Full Hamiltonian
  arma::mat Ha, Hb;

  // Hamiltonians of last iteration
  arma::mat Haold(Nbf,Nbf), Hbold(Nbf,Nbf);
  Haold.zeros();
  Hbold.zeros();
#endif

  // Mixing factor if DIIS not used
  double mix=INITMIX;

  // Dipole moment
  arma::vec dipmom;
  double olddip;

  // Tolerance for screening and screening efficiency
  double tol=ROUGHTOL;
  double screeneff;

  // Change in energy from last iteration
  double deltaE;

  double Eold=0, Eold2=0;

  // Maximum and RMS differences of AO density matrix
  double rmsdiff=0.0, maxdiff=0.0;
#ifndef RESTRICTED
  double rmsdiffa=0.0, maxdiffa=0.0;
  double rmsdiffb=0.0, maxdiffb=0.0;
#endif


  if(verbose)
    printf("\n ******* Initialization of run ********\n");


#ifdef RESTRICTED
  if(sol.C.n_rows!=Nbf)
#else
    if(sol.Ca.n_rows!=Nbf || sol.Cb.n_rows!=Nbf)
#endif
      {
	if(verbose) {
	  printf("\nNo input guess given, forming initial guess by diagonalizing core hamiltonian.\n");
	  t.set();
	}

#ifdef RESTRICTED
	Horth=trans(Sinvh)*Hcore*Sinvh; // Transform to orthogonal basis
	eig_sym_ordered(sol.E,orbs,Horth); // Solve in orthogonal basis

	// Transform back to non-orthogonal basis
	sol.C=Sinvh*orbs;
#else
	Horth=trans(Sinvh)*Hcore*Sinvh; // Transform to orthogonal basis
	eig_sym_ordered(sol.Ea,orbs,Horth); // Solve in orthogonal basis
	// Transform back to non-orthogonal basis
	sol.Ca=Sinvh*orbs;

	// Copy orbitals
	sol.Eb=sol.Ea;
	sol.Cb=sol.Ca;
#endif

	if(verbose)
	  printf("\nInitial guess formed in %s.\n",t.elapsed().c_str());

      } else {
      // Got correctly sized input guess.

      if(verbose)
        printf("\nUsing input guess for orbitals.\n");
    }


#ifdef RESTRICTED
  form_density(sol.P,sol.C,occs);
#else

#if defined(FULLHOLE) || defined(HALFHOLE)
  size_t ixc_orb;
  if(spin)
    ixc_orb=find_excited_orb(sol.Cb,*basisp,xcatom,noccb);
  else
    ixc_orb=find_excited_orb(sol.Ca,*basisp,xcatom,nocca);

  if(spin) {
#if defined(FULLHOLE)
    occb=exc_occ(ixc_orb,noccb); // Move alpha occupied states up by a notch
#else
    occb=frac_occ(ixc_orb,noccb); // Fractional occupation in alpha orbitals
#endif
    occa=norm_occ(nocca); // Normal occupation in beta
  } else {
#if defined(FULLHOLE)
    occa=exc_occ(ixc_orb,nocca); // Move alpha occupied states up by a notch
#else
    occa=frac_occ(ixc_orb,nocca); // Fractional occupation in alpha orbitals
#endif
    occb=norm_occ(noccb); // Normal occupation in beta
  }

  // End HALFHOLE || FULLHOLE
#endif

  form_density(sol.Pa,sol.Ca,occa);
  form_density(sol.Pb,sol.Cb,occb);
  sol.P=sol.Pa+sol.Pb;
#endif

  // Print orbital energies
  if(verbose) {
#ifdef RESTRICTED
    print_E(sol.E,occs);
#else
    printf("alpha: ");
    print_E(sol.Ea,occa);
    printf("beta:  ");
    print_E(sol.Eb,occb);
#endif
  }

  // Initialize change of density matrix
  deltaP=sol.P;
#ifndef RESTRICTED
  deltaPa=sol.Pa;
  deltaPb=sol.Pb;
#endif

#ifdef DFT
  // Fraction of exact exchange
  double kfrac=exact_exchange(dft.x_func);

  if(verbose) {
    if(kfrac!=0.0)
      printf("\nUsing hybrid exchange with % .3f of exact exchange.\n",kfrac*100);
    else
      printf("\nA pure exchange functional used, no exact exchange.\n");
  }

  DFTGrid grid(basisp,dft_direct,verbose,dft_lobatto);
#endif


  // Sparse output to stderr
  if(verbose) {
    fprintf(stderr,"Running ");
#if defined(RESTRICTED) || defined(_ROHF)
    fprintf(stderr,"restricted ");
#else
    fprintf(stderr,"unrestricted ");
#endif

#ifndef DFT
#ifdef _ROHF
    fprintf(stderr,"open-shell ");
#endif
    fprintf(stderr,"HF ");
#else
    if(dft.c_func>0) {
      // Correlation exists.
      fprintf(stderr,"%s-%s ",get_keyword(dft.x_func).c_str(),get_keyword(dft.c_func).c_str());
    } else
      fprintf(stderr,"%s ",get_keyword(dft.x_func).c_str());
#endif

    fprintf(stderr,"calculation");
#ifdef DFT
    if(densityfit)
      fprintf(stderr," with density fitting");

#if (defined(FULLHOLE) || defined(HALFHOLE))
    if(densityfit)
      fprintf(stderr," and ");
    else
      fprintf(stderr," with ");
#ifdef FULLHOLE
    fprintf(stderr,"full core hole");
#else HALFHOLE
    fprintf(stderr,"half core hole");
#endif
#endif

#endif // end DFT clause
    fprintf(stderr,".\n%4s %16s %10s %9s %9s %8s %10s\n","iter","E","dE","RMS dens","MAX dens","dip mom","titer (s)");
  }

#ifdef DFT
#ifdef RESTRICTED
  // Exchange-correlation functional
  arma::mat XC(Nbf,Nbf);
  // Form DFT quadrature grid
  grid.construct(sol.P,dft.gridtol,dft.x_func,dft.c_func);
#else
  // Exchange-correlation functional
  arma::mat XCa(Nbf,Nbf), XCb(Nbf,Nbf);
  // Form DFT quadrature grid
  grid.construct(sol.Pa,sol.Pb,dft.gridtol,dft.x_func,dft.c_func);
#endif

  if(verbose) {
    printf("Construction of grid took %s.\n",t.elapsed().c_str());
    printf("DFT grid has %lu points (%lu function values).\n",grid.get_Npoints(),grid.get_Nfuncs());
    grid.print_memory_req();
    printf("\n");

    fprintf(stderr,"%-61s %10.3f\n","    DFT grid formation",t.get());
  }
#endif

  // Loop:
  bool converged=0;
  for(int iiter=1;iiter<=maxiter;iiter++) {
    Timer titer;

    if(verbose)
      printf("\n ******* Iteration %4i ********\n",iiter);

    // Form Coulomb and exchange matrices
#ifdef DFT
    if(densityfit) {
      if(verbose) {
	printf("Forming density fitted Coulomb matrix ... ");
	fflush(stdout);
	t.set();
      }
      J=dfit.calc_J(sol.P);

    } else {
#endif
      if(direct) {
#ifdef RESTRICTED

#ifdef DFT
	if(kfrac!=0.0) {
#endif
	  if(verbose) {
	    printf("Computing HF Coulomb and exchange matrices.\nScreening integrals with tolerance %.3e ... ",tol);
	    fflush(stdout);
	    t.set();
	  }

	  // Calculates everything
	  //	    scr.calcJK(sol.P,J,K,tol,&screeneff);

	  // Only calculate the changed part
	  arma::mat dJ, dK;
	  scr.calcJK(deltaP,dJ,dK,tol,&screeneff);
	  J+=dJ;
	  K+=dK;

#ifdef DFT
	} else {

	  if(verbose) {
	    printf("Computing HF Coulomb matrix.\nScreening integrals with tolerance %.3e ... ",tol);
	    fflush(stdout);
	    t.set();
	  }

	  //	    J=scr.calcJ(sol.P,tol,&screeneff);
	  J+=scr.calcJ(deltaP,tol,&screeneff);
	}
#endif


#else
	// Unrestricted case
#ifdef DFT
	if(kfrac!=0.0) {
#endif
	  if(verbose) {
	    printf("Computing HF Coulomb and exchange matrices.\nScreening integrals with tolerance %.3e ... ",tol);
	    fflush(stdout);
	    t.set();
	  }

	  //	    scr.calcJK(sol.Pa,sol.Pb,J,Ka,Kb,tol,&screeneff);

	  // Only calculate the changed part
	  arma::mat dJ, dKa, dKb;
	  scr.calcJK(deltaPa,deltaPb,dJ,dKa,dKb,tol,&screeneff);
	  J+=dJ;
	  Ka+=dKa;
	  Kb+=dKb;

#ifdef DFT
	} else {

	  if(verbose) {
	    printf("Computing HF Coulomb matrix.\nScreening integrals with tolerance %.3e ... ",tol);
	    fflush(stdout);
	    t.set();
	  }

	  //	    J=scr.calcJ(sol.P,tol,&screeneff);
	  J+=scr.calcJ(deltaP,tol,&screeneff);
	}
#endif

#endif
      } else {

	// Conventional mode - use tabled integrals

	if(verbose) {

#ifdef DFT
	  if(kfrac!=0.0)
#endif
	    printf("Forming HF Coulomb and exchange matrices ... ");
#ifdef DFT
	  else
	    printf("Forming HF Coulomb matrix ... ");
#endif

	  fflush(stdout);
	  t.set();
	}

	J=tab.calcJ(sol.P);

#ifdef DFT
	if(kfrac!=0.0) {
#endif

#ifdef RESTRICTED
	  K=tab.calcK(sol.P);
#else
	  Ka=tab.calcK(sol.Pa);
	  Kb=tab.calcK(sol.Pb);
#endif

#ifdef DFT
	} // End kfrac clause
#endif

      }

#ifdef DFT
    }
#endif


    if(verbose) {
      printf("done (%s)\n",t.elapsed().c_str());
#ifdef DFT
      if(direct && !densityfit)
#else
	if(direct)
#endif
	  printf("Due to screening, only %.2f %% of the shell integrals were computed.\n",screeneff);
    }


#ifdef DFT
    if(verbose) {
      printf("Computing DFT exchange and correlation ... ");
      fflush(stdout);
      t.set();
    }

    double Nelnum; // Numerically integrated density
#ifdef RESTRICTED
    grid.eval_Fxc(dft.x_func,dft.c_func,sol.P,XC,sol.en.Exc,Nelnum);
#else
    grid.eval_Fxc(dft.x_func,dft.c_func,sol.Pa,sol.Pb,XCa,XCb,sol.en.Exc,Nelnum);
#endif

    double rel_diff=(Nelnum-Nel)*100.0/Nel;

    if(verbose) {
      printf("done (%s)\n",t.elapsed().c_str());
      printf("Numerically integrated density is %.5f (%+.4f %%).\n",Nelnum,rel_diff);
    }

    if(fabs(rel_diff)>1e-2) {
      std::ostringstream oss;
      //      oss << "Density integrated over DFT grid differs from number of electrons by " << rel_diff << " %, i.e. " << Nelnum-Nel << " electrons.\n";
      oss << "Warning - numerically integrated density seems inaccurate.\n";
      if(verbose)
	std::cout << oss.str();
      //      throw std::runtime_error(oss.str());
    }
#endif

    // Update Hamiltonian
#ifdef RESTRICTED
    Hold=sol.H;

#ifdef DFT
    sol.H=Hcore+J+XC;
    // Add exact exchange if necessary
    if(kfrac!=0.0) {
      sol.H-=0.5*kfrac*K;
      sol.en.Exc-=0.25*kfrac*arma::trace(sol.P*K);
    }
    
#else
    sol.H=Hcore+J-0.5*K;
    sol.en.Exc=-0.25*arma::trace(sol.P*K);
#endif

#else // Unrestricted case

    // Store Hamiltonians of last iteration
    Haold=sol.Ha;
    Hbold=sol.Hb;

#ifdef DFT
    sol.Ha=Hcore+J+XCa;
    sol.Hb=Hcore+J+XCb;
    if(kfrac!=0) {
      sol.Ha-=kfrac*Ka;
      sol.Hb-=kfrac*Kb;
      sol.en.Exc-=0.5*kfrac*(arma::trace(sol.Pa*Ka)+arma::trace(sol.Pb*Kb));
    }
#else
    sol.Ha=Hcore+J-Ka;
    sol.Hb=Hcore+J-Kb;
    sol.en.Exc=-0.5*(arma::trace(sol.Pa*Ka)+arma::trace(sol.Pb*Kb));

#ifdef _ROHF
    // Constrain Fock operators to correspond to ROHF
    ROHF_update(sol.Ha,sol.Hb,sol.P,S,Nel_alpha,Nel_beta);
#endif

#endif // end DFT clause

#endif // End unrestricted case

    
#if defined(FULLHOLE) || defined(HALFHOLE)
    if(freeze.size()>0) {
      // Freeze orbitals.
      if(spin)
	freeze_orbs(freeze,sol.Cb,S,sol.Hb);
      else
	freeze_orbs(freeze,sol.Ca,S,sol.Ha);
    } 
#endif // end TP clause

    // Energies
    sol.en.Ekin=arma::trace(sol.P*T);
    sol.en.Enuca=arma::trace(sol.P*Vnuc);
    sol.en.Enucr=Enuc;
    sol.en.Eone=arma::trace(sol.P*Hcore);
    sol.en.Ecoul=0.5*arma::trace(sol.P*J);

    // Compute total energies
    Eold2=Eold;
    Eold=sol.en.E;
    sol.en.Eel=sol.en.Ecoul+sol.en.Exc+sol.en.Eone;
    sol.en.E=sol.en.Eel+sol.en.Enucr;

    // Compute change of energy since last iteration
    deltaE=sol.en.E-Eold;

    // Update screening value
    tol=std::min(fabs(deltaE)*1e-2,1e-9);

    // Sanity check
    if(!std::isfinite(sol.en.E)) {
      ERROR_INFO();
      std::ostringstream oss;
      oss << "\nSomething wrong with total energy " << sol.en.E <<"?\nEnding program.\n";
      throw std::runtime_error(oss.str());
    }

    if(dynamicmix && iiter>3)
      update_mixing(mix,sol.en.E,Eold,Eold2);

    // Update ADIIS stacks
    if(useadiis) {
#ifdef RESTRICTED
      adiis.push(sol.en.E,sol.P,sol.H);
#else
      adiisa.push(sol.en.E,sol.Pa,sol.Ha);
      adiisb.push(sol.en.E,sol.Pb,sol.Hb);
#endif
    }

    if(iiter>1 && usebroyden) {
#ifdef RESTRICTED
      // Update Broyden mixer
      broyd.push_x(MatToVec(Hold));
      broyd.push_f(MatToVec(Hold-sol.H));
#else
      // Compute sum and difference
      arma::mat Hs=sol.Ha+sol.Hb;
      arma::mat Hd=sol.Ha-sol.Hb;

      arma::mat Hsold=Haold+Hbold;
      arma::mat Hdold=Haold-Hbold;

      // Update Broyden mixers
      broyd_sum.push_x(MatToVec(Hsold));
      broyd_sum.push_f(MatToVec(Hsold-Hs));

      broyd_diff.push_x(MatToVec(Hdold));
      broyd_diff.push_f(MatToVec(Hdold-Hd));
#endif
    }

    // Solve DIIS
    if(usediis) {

#ifdef RESTRICTED
      // Update DIIS stack of matrices
      diis.update(sol.H,sol.P,diiserr);
#else
      // Update DIIS stacks of matrices
      diisa.update(sol.Ha,sol.Pa,diiserra);
      diisb.update(sol.Hb,sol.Pb,diiserrb);
      diiserr=std::max(diiserra,diiserrb);
#endif

      if(diiserr<diisthr) {
	if(verbose)
	  printf("\nUsing DIIS extrapolated Fock operator.\n");

#ifdef RESTRICTED
	// Solve new matrix
	diis.solve(sol.H,diis_c1);
#else
        // Solve new matrices
	diisa.solve(sol.Ha,diis_c1);
        diisb.solve(sol.Hb,diis_c1);
#endif

	diissucc=1;
      } else {
        if(verbose)
          printf("\nDIIS error too large, not using DIIS extrapolation.\n");
	diissucc=0;
      }
    }

    // Perform ADIIS interpolation
    if(useadiis && ((usediis && !diissucc) || !usediis)) {

      if(verbose) {
	printf("Performing ADIIS interpolation of Fock operator ... ");
	fflush(stdout);
	t.set();
      }

      diissucc=1;
#ifdef RESTRICTED
      sol.H=adiis.get_H();
#else
      sol.Ha=adiisa.get_H();
      sol.Hb=adiisb.get_H();
#endif

      if(verbose)
	printf("done (%s)\n",t.elapsed().c_str());
    }

    // Perform Broyden interpolation
    if(usebroyden && ((usediis && !diissucc) || !usediis) && iiter>1) {

      if(verbose) {
	printf("Performing Broyden interpolation of Fock operator ... ");
	fflush(stdout);
	t.set();
      }

#ifdef RESTRICTED
      // Update Hamiltonian
      sol.H=VecToMat(broyd.update_x(),Nbf,Nbf);
#else
      arma::mat Hs=VecToMat(broyd_sum.update_x(),Nbf,Nbf);
      arma::mat Hd=VecToMat(broyd_diff.update_x(),Nbf,Nbf);

      // Update Hamiltonians
      sol.Ha=0.5*(Hs+Hd);
      sol.Hb=0.5*(Hs-Hd);
#endif

      if(verbose)
	printf("done (%s)\n",t.elapsed().c_str());
    }

    // Solve FC=ESC
    if(verbose) {
      printf("\nSolving SCF equations ... ");
      fflush(stdout);
      t.set();
    }

#ifdef RESTRICTED
    // Transform Hamiltonian into orthogonal basis
    Horth=arma::trans(Sinvh)*sol.H*Sinvh;
    // Update orbitals and energies
    eig_sym_ordered(sol.E,orbs,Horth);
    // Transform back to non-orthogonal basis
    sol.C=Sinvh*orbs;
#else
    Horth=trans(Sinvh)*sol.Ha*Sinvh;
    eig_sym_ordered(sol.Ea,orbs,Horth);
    sol.Ca=Sinvh*orbs;

    Horth=trans(Sinvh)*sol.Hb*Sinvh;
    eig_sym_ordered(sol.Eb,orbs,Horth);
    sol.Cb=Sinvh*orbs;
#endif

    if(verbose)
      printf("done (%s)\n",t.elapsed().c_str());

    // Form new density matrix
    arma::mat Pnew;
#ifdef RESTRICTED
    form_density(Pnew,sol.C,occs);
#else
    arma::mat Panew, Pbnew;

#if defined(FULLHOLE) || defined(HALFHOLE)
  size_t ixc_orb;
  if(spin)
    ixc_orb=find_excited_orb(sol.Cb,*basisp,xcatom,noccb);
  else
    ixc_orb=find_excited_orb(sol.Ca,*basisp,xcatom,nocca);

  if(spin) {
#if defined(FULLHOLE)
    occb=exc_occ(ixc_orb,noccb); // Move alpha occupied states up by a notch
#else
    occb=frac_occ(ixc_orb,noccb); // Fractional occupation in alpha orbitals
#endif
    occa=norm_occ(nocca); // Normal occupation in beta
  } else {
#if defined(FULLHOLE)
    occa=exc_occ(ixc_orb,nocca); // Move alpha occupied states up by a notch
#else
    occa=frac_occ(ixc_orb,nocca); // Fractional occupation in alpha orbitals
#endif
    occb=norm_occ(noccb); // Normal occupation in beta
  }

  // End HALFHOLE || FULLHOLE
#endif

    
    form_density(Panew,sol.Ca,occa);
    form_density(Pbnew,sol.Cb,occb);
    Pnew=Panew+Pbnew;
#endif

    // Compute change of (total) density
    deltaP=Pnew-sol.P;
#ifndef RESTRICTED
    // Compute change of polarized densities
    deltaPa=Panew-sol.Pa;
    deltaPb=Pbnew-sol.Pb;
#endif

    // Compute dipole moment
    olddip=norm(dipmom);
    dipmom=dipole_moment(Pnew,*basisp);

    // Compute convergence criteria
#ifdef RESTRICTED
    maxdiff=max_abs(deltaP);
    rmsdiff=rms_norm(deltaP);
#else
    maxdiffa=max_abs(deltaPa);
    maxdiffb=max_abs(deltaPb);

    rmsdiffa=rms_norm(deltaPa);
    rmsdiffb=rms_norm(deltaPb);

    maxdiff=std::max(maxdiffa,maxdiffb);
    rmsdiff=std::max(rmsdiffa,rmsdiffb);
    //    rmsdiff=sqrt(rmsdiffa*rmsdiffa+rmsdiffb*rmsdiffb)/2.0;
#endif


    if(mixdensity) {
      if(verbose)
	printf("Mixing density matrices with mixing factor %g.\n",mix);

      sol.P=(1.0-mix)*sol.P+mix*Pnew;
#ifndef RESTRICTED
      sol.Pa=(1.0-mix)*sol.Pa+mix*Panew;
      sol.Pb=(1.0-mix)*sol.Pb+mix*Pbnew;
#endif
    } else {
      sol.P=Pnew;
#ifndef RESTRICTED
      sol.Pa=Panew;
      sol.Pb=Pbnew;
#endif
    }

    // Print out status information
    if(verbose) {

#ifdef RESTRICTED
      print_E(sol.E,occs);
#else
      printf("alpha: ");
      print_E(sol.Ea,occa);
      printf("beta:  ");
      print_E(sol.Eb,occb);
#endif

      printf("\nDipole:\tx\t\ty\t\tz\t\tdipole change\n");
      printf("\t% 08.8f\t% 08.8f\t% 08.8f\t% e\n",dipmom(0),dipmom(1),dipmom(2),norm(dipmom)-olddip);

      printf("Energy:\telectronic\ttotal\t\tvirial\t\tenergy change\n");
      printf("\t% 08.8f\t% 08.8f\t% 08.8f\t% g\n",sol.en.Eel,sol.en.E,-sol.en.E/sol.en.Ekin,deltaE);

#ifdef DFT
      printf("\tkinetic\t\tnuclear\t\tCoulomb\t\tXC\n");
#else
      // No correlation in Hartree-Fock!
      printf("\tkinetic\t\tnuclear\t\tCoulomb\t\tExchange\n");
#endif
      printf("\t% 08.8f\t% 08.8f\t% 08.8f\t% 08.8f\n",sol.en.Ekin,sol.en.Enuca,sol.en.Ecoul,sol.en.Exc);

#ifdef RESTRICTED
      if(usediis) {
	printf("Errors:\tMax dens\tRMS dens\tDIIS\n");
	printf("\t% e\t% e\t% e\n",maxdiff,rmsdiff,diiserr);
      } else {
	printf("Errors:\tMax dens\tRMS dens\n");
	printf("\t% e\t% e\n",maxdiff,rmsdiff);
      }
#else
      if(usediis) {
        printf("Errors:\tMax dens\tRMS dens\tDIIS\n");
        printf("alpha\t%e\t%e\t%e\n",maxdiffa,rmsdiffa,diiserra);
        printf("beta\t%e\t%e\t%e\n",maxdiffb,rmsdiffb,diiserrb);
      } else {
        printf("Errors:\tMax dens\tRMS dens\n");
        printf("alpha\t%e\t%e\n",maxdiffa,rmsdiffa);
        printf("beta\t%e\t%e\n",maxdiffb,rmsdiffb);
      }
#endif

      printf("\nIteration took %s.\n",titer.elapsed().c_str());
    }

    // Sparse output
    if(verbose)
      fprintf(stderr,"%4i % 16.8f % 10.3e %9.3e %9.3e %8.3f %10.3f\n",iiter,sol.en.E,deltaE,rmsdiff,maxdiff,norm(dipmom),titer.get());

    if(!mixdensity || (mixdensity && mix==1.0)) {

      if(fabs(deltaE)<conv.deltaEmax && maxdiff<conv.deltaPmax && rmsdiff<conv.deltaPrms) {
	if(verbose)
	  printf("\n ******* Convergence achieved ********\n");
	converged=1;
      }
    } // End convergence check clause

    // Pad occupancies with zeros (needed e.g. in Casida routines)
#if !defined(RESTRICTED)
    std::vector<double> occar(occa), occbr(occb);
    while(occar.size()<Sinvh.n_cols)
      occar.push_back(0.0);
    while(occbr.size()<Sinvh.n_cols)
      occbr.push_back(0.0);
#else
    std::vector<double> occr(occs);
    while(occr.size()<Sinvh.n_cols)
      occr.push_back(0.0);
#endif
    
    // Write current matrices to checkpoint.
    chkptp->write("P",sol.P);
#if !defined(RESTRICTED)
    chkptp->write("Ca",sol.Ca);
    chkptp->write("Cb",sol.Cb);
    
    chkptp->write("Ea",sol.Ea);
    chkptp->write("Eb",sol.Eb);
    
    chkptp->write("Pa",sol.Pa);
    chkptp->write("Pb",sol.Pb);

    chkptp->write("occa",occar);
    chkptp->write("occb",occbr);

    // Restricted
    chkptp->write("Restricted",0);
#else
    chkptp->write("C",sol.C);
    chkptp->write("E",sol.E);
    chkptp->write("occs",occr);
    // Unrestricted
    chkptp->write("Restricted",1);
#endif
    chkptp->write("Converged",converged);

    if(converged)
      break;
  } // End SCF cycle

  // Compute dipole moment
  if(verbose) {
    arma::vec dp=dipole_moment(sol.P,*basisp);
    printf("Dipole moment is (%f,%f,%f) D, |mu|=%f D.\n",dp[0]/AUINDEBYE,dp[1]/AUINDEBYE,dp[2]/AUINDEBYE,norm(dp)/AUINDEBYE);
  }

  if(converged) {
    if(verbose) {
      std::string method=
#ifdef RESTRICTED
	     "R"
#elif defined(_ROHF)
	     "RO"
#else
	     "U"
#endif
#ifdef DFT
	     "DFT"
#else
	     "HF"
#endif
	;

      printf("Solution of %s took %s.\n",method.c_str(),ttot.elapsed().c_str());
      fprintf(stderr,"%s converged in %s.\n\n",method.c_str(),ttot.elapsed().c_str());
    }
  } else {
    std::ostringstream oss;
    oss << "Error in function " << __FUNCTION__ << " (file " << __FILE__ << ", near line " << __LINE__ << "): SCF did not converge in "<<maxiter<<" iterations!\n";
    throw std::runtime_error(oss.str());
  }

#if defined(HALFHOLE) || defined(FULLHOLE)
  return ixc_orb;
#endif
}
