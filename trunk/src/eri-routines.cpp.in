/*
 *                This source code is part of
 * 
 *                     E  R  K  A  L  E
 *                             -
 *                       DFT from Hel
 *
 * Written by Susi Lehtola, 2010-2013
 * Copyright (c) 2010-2013, Susi Lehtola
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 */

/*
  Routines for computing ERIs. The same algorithm is used both for
  conventional and direct calculations.
*/

/* Function definitions */

#if defined(ERITABLE)
void ERItable::fill(const BasisSet * basp, double shtol, double tol, bool verbose) {
#endif

#if defined(CALCJKab)
#ifndef FORCE
void ERIscreen::calcJK(const arma::mat & Pa, const arma::mat & Pb, arma::mat & J, arma::mat & Ka, arma::mat & Kb, double tol, double *eff) const
#else
void ERIscreen::forceJK(const arma::mat & Pa, const arma::mat & Pb, arma::vec & fJ, arma::vec & fKa, arma::vec & fKb, double tol, double *eff) const
#endif
{
  // Compute total density for Coulomb matrix
  arma::mat P=Pa+Pb;
#endif

#if defined(CALCKab)
#ifndef FORCE
void ERIscreen::calcK(const arma::mat & Pa, const arma::mat & Pb, arma::mat & Ka, arma::mat & Kb, double tol, double *eff) const
#else
void ERIscreen::forceK(const arma::mat & Pa, const arma::mat & Pb, arma::vec & fKa, arma::vec & fKb, double tol, double *eff) const
#endif
{
  // Compute total density for Coulomb matrix
  arma::mat P=Pa+Pb;
#endif


#if defined(CALCJK)
#ifndef FORCE
void ERIscreen::calcJK(const arma::mat & P, arma::mat & J, arma::mat & K, double tol, double *eff) const {
#else
void ERIscreen::forceJK(const arma::mat & P, arma::vec & fJ, arma::vec & fK, double tol, double *eff) const {
#endif
#endif

#if defined(CALCK)
#ifndef FORCE
arma::mat ERIscreen::calcK(const arma::mat & P, double tol, double *eff) const {
  arma::mat K;
#else
arma::vec ERIscreen::forceK(const arma::mat & P, double tol, double *eff) const {
  arma::vec fK;
#endif
#endif

#if defined(CALCJ)
#ifndef FORCE
arma::mat ERIscreen::calcJ(const arma::mat & P, double tol, double *eff) const {
  arma::mat J;
#else
arma::vec ERIscreen::forceJ(const arma::mat & P, double tol, double *eff) const {
  arma::vec fJ;
#endif
#endif
  
  // Amount of basis functions
  size_t Nbf=basp->get_Nbf();
  // Shells
  std::vector<GaussianShell> shells=basp->get_shells();

  /* Check sizes of input */
#ifndef FORCE
#if defined(CALCJ) || defined(CALCJK) || defined(CALCJKab)
#define DO_J
  J.zeros(Nbf,Nbf);
#endif
  
#if defined(CALCK) || defined(CALCJK)
#define DO_K
  K.zeros(Nbf,Nbf);
#endif

#if defined(CALCJKab) || defined(CALCKab)
  Ka.zeros(Nbf,Nbf);
  Kb.zeros(Nbf,Nbf);
#endif

#else // FORCE

#if defined(CALCJ) || defined(CALCJK) || defined(CALCJKab)
#define DO_J
  fJ.zeros(3*basp->get_Nnuc());
#endif

#if defined(CALCK) || defined(CALCJK)
#define DO_K
  fK.zeros(3*basp->get_Nnuc());
#endif

#if defined(CALCJKab) || defined(CALCKab)
  fKa.zeros(3*basp->get_Nnuc());
  fKb.zeros(3*basp->get_Nnuc());
#endif
#endif // FORCE


#if defined(CALCJKab) || defined(CALCKab)
#define DO_Kab
  MAT_SIZE_CHECK(Pa,Nbf,Nbf);
  MAT_SIZE_CHECK(Pb,Nbf,Nbf);
#endif

#if defined(DO_J) || defined(DO_K)
  MAT_SIZE_CHECK(P,Nbf,Nbf);
#endif

  /* Allocate memory for table of integrals */
#ifdef ERITABLE
  // Make index helper
  iidx=i_idx(Nbf*(Nbf+1)/2);
  // Make pairs helper
  for(size_t i=0;i<Nbf;i++)
    for(size_t j=0;j<=i;j++) {
      bfpair_t tmp;
      tmp.i=i;
      tmp.j=j;
      pairs.push_back(tmp);
    }

  // Compute memory requirements
  size_t N;
  N=N_ints(basp);

  // Don't do DOS
  if(N*sizeof(double)>14*1e9) {
    ERROR_INFO();
    throw std::out_of_range("Cowardly refusing to allocate more than 14 gigs of memory.\n");
  }

  try {
    ints.reserve(N);
    ints.resize(N);
  } catch(std::bad_alloc err) {
    std::ostringstream oss;

    ERROR_INFO();
    oss << "Was unable to reserve " << memory_size(N*sizeof(double)) << " of memory.\n";
    throw std::runtime_error(oss.str());
  }

  // Initialize with zeros
  for(size_t i=0;i<N;i++)
    ints[i]=0.0;
#endif

  // Number of calculated and skipped integrals
  size_t intskip=0, calcd=0;
#ifndef ERITABLE
  size_t denskip=0;
#endif

  /* The filling algorithm may seem a bit complicated. This is because the ERIs
     are computed on a shell basis, and because the same algorithm is used here
     to form the ERIs as for direct calculations.
  */

#ifdef ERITABLE
  // Get ERI screening matrix and list of unique shell pairs
  arma::mat screen;
  std::vector<eripair_t> shpairs=basp->get_eripairs(screen,shtol,verbose);
#endif
  // Get number of shell pairs
  const size_t Npairs=shpairs.size();

#if !defined(ERITABLE)
  const size_t Nsh=basp->get_Nshells();
  arma::mat Psh(Nsh,Nsh);
  Psh.zeros();

  // Collect maximum density
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(size_t ip=0;ip<Npairs;ip++) {
    // Shells are
    size_t is=shpairs[ip].is;
    size_t js=shpairs[ip].js;
    // First functions on shells are
    size_t i0=basp->get_first_ind(is);
    size_t j0=basp->get_first_ind(js);
    // Indices of last functions on shells
    size_t ilast=basp->get_last_ind(is);
    size_t jlast=basp->get_last_ind(js);

    // Maximum value of density is
    Psh(is,js)=max_abs(P.submat(i0,j0,ilast,jlast));
    Psh(js,is)=Psh(is,js);
  }
#endif

  // Loop over first pairs
#ifdef _OPENMP

#ifdef ERITABLE
#pragma omp parallel
#else
#pragma omp parallel reduction(+:calcd,intskip,denskip)
#endif
#endif // ifdef _OPENMP
  { // Open parallel region

#ifndef FORCE
    /// ERI worker
    ERIWorker *eri;
#else
    /// ERI worker
    dERIWorker *deri;
#endif
    
    
#ifndef FORCE
    if(omega==0.0)
      eri=new ERIWorker(basp->get_max_am(),basp->get_max_Ncontr());
    else
      eri=new ERIWorker_srlr(basp->get_max_am(),basp->get_max_Ncontr(),omega,alpha,beta);
#else
    if(omega==0.0)
      deri=new dERIWorker(basp->get_max_am(),basp->get_max_Ncontr());
    else
      deri=new dERIWorker_srlr(basp->get_max_am(),basp->get_max_Ncontr(),omega,alpha,beta);
#endif
    
    /// Integral array
    const std::vector<double> * erip;

#ifndef FORCE
#ifdef DO_J
    arma::mat Jwrk(J);
#endif

#ifdef DO_K
    arma::mat Kwrk(K);
#endif

#ifdef DO_Kab
    arma::mat Kawrk(Ka);
    arma::mat Kbwrk(Kb);
#endif

#else // FORCE

#ifdef DO_J
    arma::vec fJwrk(fJ);
#endif

#ifdef DO_K
    arma::vec fKwrk(fK);
#endif

#ifdef DO_Kab
    arma::vec fKawrk(fKa);
    arma::vec fKbwrk(fKb);
#endif

#endif // FORCE

#ifdef _OPENMP
#pragma omp for schedule(dynamic)
#endif
    for(size_t ip=0;ip<Npairs;ip++) {
      // Loop over second pairs
      for(size_t jp=0;jp<=ip;jp++) {

	// Shells on second pair are
	size_t ks=shpairs[ip].is;
	size_t ls=shpairs[ip].js;
	// and those on the first pair
	size_t is=shpairs[jp].is;
	size_t js=shpairs[jp].js;

	// First functions on shells are
	size_t k0=basp->get_first_ind(ks);
	size_t l0=basp->get_first_ind(ls);
	// and on the first pair
	size_t i0=basp->get_first_ind(is);
	size_t j0=basp->get_first_ind(js);

	// Amount of functions on the second pair
	size_t Nk=basp->get_Nbf(ks);
	size_t Nl=basp->get_Nbf(ls);
	// and on the first pair
	size_t Ni=basp->get_Nbf(is);
	size_t Nj=basp->get_Nbf(js);

	// Maximum value of the 2-electron integrals on this shell pair
	double intmax=screen(is,js)*screen(ks,ls);
	if(intmax<tol) {
	  // Skip due to small value of integral. Because the
	  // integrals have been ordered, all the next ones will be
	  // small as well!
	  intskip+=is-js+1;
	  break;
	}

	// Increment amount of calculated integrals
	calcd++;

#ifndef FORCE
	// Compute integrals
	eri->compute(&shells[is],&shells[js],&shells[ks],&shells[ls]);
	erip=eri->getp();

#ifdef ERITABLE
	// Store integrals
	for(size_t ii=0;ii<Ni;ii++)
	  for(size_t jj=0;jj<Nj;jj++)
	    for(size_t kk=0;kk<Nk;kk++)
	      for(size_t ll=0;ll<Nl;ll++)
		ints[idx(i0+ii,j0+jj,k0+kk,l0+ll)]=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
#endif

	// Increment matrices.
#ifdef DO_J

	// J_ij = (ij|kl) P_kl
	{
	  // Work matrix
	  arma::mat Jij(Ni,Nj);
	  Jij.zeros();
	  arma::mat Pkl=P.submat(k0,l0,k0+Nk-1,l0+Nl-1);

	  // Degeneracy factor
	  double fac=1.0;
	  if(ks!=ls)
	    fac=2.0;

	  /* Increment matrix */
	  for(size_t ii=0;ii<Ni;ii++) 
	    for(size_t jj=0;jj<Nj;jj++) {

	      // Matrix element
	      double el=0.0;
	      for(size_t kk=0;kk<Nk;kk++)
		for(size_t ll=0;ll<Nl;ll++)
		  el+=Pkl(kk,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];

	      // Set the element
	      Jij(ii,jj)+=fac*el;
	    }

	  // Store the matrix element
	  Jwrk.submat(i0,j0,i0+Ni-1,j0+Nj-1)+=Jij;
	  if(is!=js)
	    Jwrk.submat(j0,i0,j0+Nj-1,i0+Ni-1)+=arma::trans(Jij);
	}

	// Permutation:
	// J_kl = (ij|kl) P_ij
	if(ip!=jp) {
	  // Work matrix
	  arma::mat Jkl(Nk,Nl);
	  Jkl.zeros();
	  arma::mat Pij=P.submat(i0,j0,i0+Ni-1,j0+Nj-1);

	  // Degeneracy factor
	  double fac=1.0;
	  if(is!=js)
	    fac=2.0;

	  /* Increment matrix */
	  for(size_t kk=0;kk<Nk;kk++)
	    for(size_t ll=0;ll<Nl;ll++) {

	      // Matrix element
	      double el=0.0;
	      for(size_t ii=0;ii<Ni;ii++) {
		for(size_t jj=0;jj<Nj;jj++) {
		  el+=Pij(ii,jj)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
		}
	      }
	      
	      // Set the element
	      Jkl(kk,ll)+=fac*el;
	    }

	  // Store the matrix element
	  Jwrk.submat(k0,l0,k0+Nk-1,l0+Nl-1)+=Jkl;
	  if(ks!=ls)
	    Jwrk.submat(l0,k0,l0+Nl-1,k0+Nk-1)+=arma::trans(Jkl);
	}
#endif

#if defined(DO_K) || defined(DO_Kab)
	{
	  /* When all indices are different, the following integrals are
	     equivalent:

	     (ij|kl) (ij|lk) (ji|kl) (ji|lk)
	     (kl|ij) (kl|ji) (lk|ij) (lk|ji)

	     This translates to

	     K(i,k) += (ij|kl) P(j,l) // always
	     K(j,k) += (ij|kl) P(i,l) // if (is!=js)
	     K(i,l) += (ij|kl) P(j,k) // if (ls!=ks)
	     K(j,l) += (ij|kl) P(i,k) // if (is!=js) and (ls!=ks)

	     and for ij != kl

	     K(k,i) += (ij|kl) P(j,l) // always
	     K(k,j) += (ij|kl) P(i,l) // if (is!=js)
	     K(l,i) += (ij|kl) P(j,k) // if (ks!=ls)
	     K(l,j) += (ij|kl) P(i,k) // if (is!=js) and (ks!=ls)

	     However, the latter four permutations just make the
	     exchange matrix symmetric. So the only thing we need to do
	     is do the first four permutations, and at the end we sum up
	     K_ij and K_ji for j>i and set K_ij and K_ji to this
	     value. This makes things a *lot* easier. So:

	     We just need to check if the shells are different, in which
	     case K will get extra incremenets.
	  */

	  // First, do the ik part:  K(i,k) += (ij|kl) P(j,l)
	  {
#ifdef DO_K
	    arma::mat Kik(Ni,Nk);
	    Kik.zeros();
	    arma::mat Pjl =P.submat(j0,l0,j0+Nj-1,l0+Nl-1);
#else
	    arma::mat Kaik(Ni,Nk);
	    Kaik.zeros();
	    arma::mat Pajl=Pa.submat(j0,l0,j0+Nj-1,l0+Nl-1);

	    arma::mat Kbik(Ni,Nk);
	    Kbik.zeros();
	    arma::mat Pbjl=Pb.submat(j0,l0,j0+Nj-1,l0+Nl-1);
#endif

	    // Increment Kik
	    for(size_t ii=0;ii<Ni;ii++)
	      for(size_t kk=0;kk<Nk;kk++)
		for(size_t ll=0;ll<Nl;ll++)
		  for(size_t jj=0;jj<Nj;jj++)
		    {
#ifdef DO_K
		      Kik (ii,kk)+=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pjl (jj,ll);
#else
		      Kaik(ii,kk)+=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pajl(jj,ll);
		      Kbik(ii,kk)+=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pbjl(jj,ll);
#endif
		    }

	    // Set elements
	    for(size_t ii=0;ii<Ni;ii++)
	      for(size_t kk=0;kk<Nk;kk++) {
		size_t i=i0+ii;
		size_t k=k0+kk;
#ifdef DO_K
		Kwrk(i,k)+=Kik(ii,kk);
#else
		Kawrk(i,k)+=Kaik(ii,kk);
		Kbwrk(i,k)+=Kbik(ii,kk);
#endif
	      }

	    // Symmetrize if necessary
	    if(ip!=jp)
	      for(size_t kk=0;kk<Nk;kk++)
		for(size_t ii=0;ii<Ni;ii++) {
		  size_t i=i0+ii;
		  size_t k=k0+kk;
#ifdef DO_K
		  Kwrk(k,i)+=Kik(ii,kk);
#else
		  Kawrk(k,i)+=Kaik(ii,kk);
		  Kbwrk(k,i)+=Kbik(ii,kk);
#endif
		}
	  }


	  // Then, the second part
	  // K(j,k) += (ij|kl) P(i,l)
	  if(is!=js) {
#ifdef DO_K
	    arma::mat Kjk(Nj,Nk);
	    Kjk.zeros();
	    arma::mat Pil=P.submat(i0,l0,i0+Ni-1,l0+Nl-1);
#else
	    arma::mat Kajk(Nj,Nk);
	    arma::mat Kbjk(Nj,Nk);
	    Kajk.zeros();
	    Kbjk.zeros();
	    arma::mat Pail=Pa.submat(i0,l0,i0+Ni-1,l0+Nl-1);
	    arma::mat Pbil=Pb.submat(i0,l0,i0+Ni-1,l0+Nl-1);
#endif

	    // Increment Kjk
	    for(size_t jj=0;jj<Nj;jj++)
	      for(size_t kk=0;kk<Nk;kk++)
		for(size_t ll=0;ll<Nl;ll++)
		  for(size_t ii=0;ii<Ni;ii++) {
#ifdef DO_K
		    Kjk(jj,kk)+=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pil(ii,ll);
#else
		    Kajk(jj,kk)+=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pail(ii,ll);
		    Kbjk(jj,kk)+=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pbil(ii,ll);
#endif
		  }

	    // Set elements
	    for(size_t jj=0;jj<Nj;jj++)
	      for(size_t kk=0;kk<Nk;kk++) {
		size_t j=j0+jj;
		size_t k=k0+kk;
#ifdef DO_K
		Kwrk(j,k)+=Kjk(jj,kk);
#else
		Kawrk(j,k)+=Kajk(jj,kk);
		Kbwrk(j,k)+=Kbjk(jj,kk);
#endif
	      }

	    // Symmetrize if necessary (take care about possible overlap with next routine)
	    if(ip!=jp) {
	      for(size_t kk=0;kk<Nk;kk++)
		for(size_t jj=0;jj<Nj;jj++) {
		  size_t j=j0+jj;
		  size_t k=k0+kk;
#ifdef DO_K
		  Kwrk(k,j)+=Kjk(jj,kk);
#else
		  Kawrk(k,j)+=Kajk(jj,kk);
		  Kbwrk(k,j)+=Kbjk(jj,kk);
#endif
		}
	    }
	  }


	  // Third part
	  //  K(i,l) += (ij|kl) P(j,k)
	  if(ks!=ls) {
#ifdef DO_K
	    arma::mat Kil(Ni,Nl);
	    Kil.zeros();
	    arma::mat Pjk=P.submat(j0,k0,j0+Nj-1,k0+Nk-1);
#else
	    arma::mat Kail(Ni,Nl);
	    arma::mat Kbil(Ni,Nl);
	    Kail.zeros();
	    Kbil.zeros();
	    arma::mat Pajk=Pa.submat(j0,k0,j0+Nj-1,k0+Nk-1);
	    arma::mat Pbjk=Pb.submat(j0,k0,j0+Nj-1,k0+Nk-1);
#endif

	    // Increment Kil
	    for(size_t ii=0;ii<Ni;ii++)
	      for(size_t ll=0;ll<Nl;ll++)
		for(size_t jj=0;jj<Nj;jj++)
		  for(size_t kk=0;kk<Nk;kk++) {
#ifdef DO_K
		    Kil(ii,ll)+=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pjk(jj,kk);
#else
		    Kail(ii,ll)+=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pajk(jj,kk);
		    Kbil(ii,ll)+=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pbjk(jj,kk);
#endif
		  }

	    // Set elements
	    for(size_t ii=0;ii<Ni;ii++)
	      for(size_t ll=0;ll<Nl;ll++) {
		size_t i=i0+ii;
		size_t l=l0+ll;
#ifdef DO_K
		Kwrk(i,l)+=Kil(ii,ll);
#else
		Kawrk(i,l)+=Kail(ii,ll);
		Kbwrk(i,l)+=Kbil(ii,ll);
#endif
	      }

	    // Symmetrize if necessary
	    if(ip!=jp)
	      for(size_t ll=0;ll<Nl;ll++)
		for(size_t ii=0;ii<Ni;ii++) {
		  size_t i=i0+ii;
		  size_t l=l0+ll;
#ifdef DO_K
		  Kwrk(l,i)+=Kil(ii,ll);
#else
		  Kawrk(l,i)+=Kail(ii,ll);
		  Kbwrk(l,i)+=Kbil(ii,ll);
#endif
		}
	  }


	  // Last permutation
	  // K(j,l) += (ij|kl) P(i,k)
	  if(is!=js && ks!=ls) {
#ifdef DO_K
	    arma::mat Kjl(Nj,Nl);
	    Kjl.zeros();
	    arma::mat Pik=P.submat(i0,k0,i0+Ni-1,k0+Nk-1);
#else
	    arma::mat Kajl(Nj,Nl);
	    arma::mat Kbjl(Nj,Nl);
	    Kajl.zeros();
	    Kbjl.zeros();
	    arma::mat Paik=Pa.submat(i0,k0,i0+Ni-1,k0+Nk-1);
	    arma::mat Pbik=Pb.submat(i0,k0,i0+Ni-1,k0+Nk-1);
#endif

	    // Increment Kjl
	    for(size_t jj=0;jj<Nj;jj++)
	      for(size_t ll=0;ll<Nl;ll++)
		for(size_t ii=0;ii<Ni;ii++)
		  for(size_t kk=0;kk<Nk;kk++) {
#ifdef DO_K
		    Kjl(jj,ll)+=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pik(ii,kk);
#else
		    Kajl(jj,ll)+=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Paik(ii,kk);
		    Kbjl(jj,ll)+=(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pbik(ii,kk);
#endif
		  }

	    // Set elements
	    for(size_t jj=0;jj<Nj;jj++)
	      for(size_t ll=0;ll<Nl;ll++) {
		size_t j=j0+jj;
		size_t l=l0+ll;
#ifdef DO_K
		Kwrk(j,l)+=Kjl(jj,ll);
#else
		Kawrk(j,l)+=Kajl(jj,ll);
		Kbwrk(j,l)+=Kbjl(jj,ll);
#endif
	      }

	    // Symmetrize if necessary
	    if (ip!=jp)
	      for(size_t ll=0;ll<Nl;ll++)
		for(size_t jj=0;jj<Nj;jj++) {
		  size_t j=j0+jj;
		  size_t l=l0+ll;
#ifdef DO_K
		  Kwrk(l,j)+=Kjl(jj,ll);
#else
		  Kawrk(l,j)+=Kajl(jj,ll);
		  Kbwrk(l,j)+=Kbjl(jj,ll);
#endif
		}
	  }
	}
#endif // ifdef DO_K || DO_Kab

#else // FORCE

	// Shell centers
	size_t inuc=shells[is].get_center_ind();
	size_t jnuc=shells[js].get_center_ind();
	size_t knuc=shells[ks].get_center_ind();
	size_t lnuc=shells[ls].get_center_ind();

	// Skip when all functions are on the same nucleus
	if(inuc==jnuc && jnuc==knuc && knuc==lnuc)
	  continue;

	// Compute the derivatives.
	deri->compute(&shells[is],&shells[js],&shells[ks],&shells[ls]);

#ifdef DO_J
	  arma::vec Jforce(12);
	  Jforce.zeros();

	  // E_J = P_ij (ij|kl) P_kl. Work matrices
	  arma::mat Pij=P.submat(i0,j0,i0+Ni-1,j0+Nj-1);
	  arma::mat Pkl=P.submat(k0,l0,k0+Nk-1,l0+Nl-1);
	  
	  // Degeneracy factor
	  double Jfac=-0.5;
	  if(is!=js)
	    Jfac*=2.0;
	  if(ks!=ls)
	    Jfac*=2.0;
	  if(ip!=jp)
	    Jfac*=2.0;
#endif

#ifdef DO_K
	  arma::vec Kforce(12);
	  Kforce.zeros();

	  // E_K = P_ik (ij|kl) P_jl
	  arma::mat Pik=P.submat(i0,k0,i0+Ni-1,k0+Nk-1);
	  arma::mat Pjl=P.submat(j0,l0,j0+Nj-1,l0+Nl-1);
	  //     + P_jk (ij|kl) P_il
	  arma::mat Pjk=P.submat(j0,k0,j0+Nj-1,k0+Nk-1);
	  arma::mat Pil=P.submat(i0,l0,i0+Ni-1,l0+Nl-1);
#endif

#ifdef DO_Kab
	  arma::vec Kaforce(12);
	  Kaforce.zeros();
	  arma::vec Kbforce(12);
	  Kbforce.zeros();

	  // E_K = P_ik (ij|kl) P_jl
	  arma::mat Paik=Pa.submat(i0,k0,i0+Ni-1,k0+Nk-1);
	  arma::mat Pbik=Pb.submat(i0,k0,i0+Ni-1,k0+Nk-1);
	  arma::mat Pajl=Pa.submat(j0,l0,j0+Nj-1,l0+Nl-1);
	  arma::mat Pbjl=Pb.submat(j0,l0,j0+Nj-1,l0+Nl-1);
	  //     + P_jk (ij|kl) P_il
	  arma::mat Pajk=Pa.submat(j0,k0,j0+Nj-1,k0+Nk-1);
	  arma::mat Pbjk=Pb.submat(j0,k0,j0+Nj-1,k0+Nk-1);
	  arma::mat Pail=Pa.submat(i0,l0,i0+Ni-1,l0+Nl-1);
	  arma::mat Pbil=Pb.submat(i0,l0,i0+Ni-1,l0+Nl-1);
#endif

#if defined(DO_K) || defined(DO_Kab)
	  double K1fac, K2fac;
	  if(is!=js && ks!=ls) {
	    // Get both twice.
	    K1fac=1.0;
	    K2fac=1.0;
	  } else if(is==js && ks==ls) {
	    // Only get the first one, once.
	    K1fac=0.5;
	    K2fac=0.0;
	  } else {
	    // Get both once.
	    K1fac=0.5;
	    K2fac=0.5;
	  }

	  // Switch symmetry
	  if(ip!=jp) {
	    K1fac*=2.0;
	    K2fac*=2.0;
	  }
	  
#ifdef DO_K
	  // Restricted case - only get half
	  K1fac/=2;
	  K2fac/=2;
#endif
#endif


	  // Increment the forces.
	  for(int idx=0;idx<12;idx++) {
	    // Get the integral derivatives
	    erip=deri->getp(idx);

#ifdef DO_J
	    {
	      // E_J = P_ij (ij|kl) P_kl
	      double el=0.0;
	      /* Increment matrix */
	      for(size_t ii=0;ii<Ni;ii++) 
		for(size_t jj=0;jj<Nj;jj++)
		  for(size_t kk=0;kk<Nk;kk++)
		    for(size_t ll=0;ll<Nl;ll++)
		      el+=Pij(ii,jj)*Pkl(kk,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
	      
	      // Set the element
	      Jforce(idx)=Jfac*el;
	    }
#endif // DO_J
	    
	    
#ifdef DO_K
	    // E_K = P_ik (ij|kl) P_jl
	    {
	      double el=0.0;
	      /* Increment matrix */
	      for(size_t ii=0;ii<Ni;ii++) 
		for(size_t jj=0;jj<Nj;jj++)
		  for(size_t kk=0;kk<Nk;kk++)
		    for(size_t ll=0;ll<Nl;ll++)
		      el+=Pik(ii,kk)*Pjl(jj,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
	      
	      // Set the element
	      Kforce(idx)=K1fac*el;
	      

	      if(K2fac!=0.0) {
		el=0.0;
		/* Increment matrix */
		for(size_t ii=0;ii<Ni;ii++) 
		  for(size_t jj=0;jj<Nj;jj++)
		    for(size_t kk=0;kk<Nk;kk++)
		      for(size_t ll=0;ll<Nl;ll++)
			el+=Pjk(jj,kk)*Pil(ii,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
		
		// Increment the element
		Kforce(idx)+=K2fac*el;
	      }
	    }
#endif

#ifdef DO_Kab
	    // E_K = P_ik (ij|kl) P_jl
	    {
	      double ael=0.0, bel=0.0;
	      /* Increment matrix */
	      for(size_t ii=0;ii<Ni;ii++) 
		for(size_t jj=0;jj<Nj;jj++)
		  for(size_t kk=0;kk<Nk;kk++)
		    for(size_t ll=0;ll<Nl;ll++)
		      ael+=Paik(ii,kk)*Pajl(jj,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
	      for(size_t ii=0;ii<Ni;ii++) 
		for(size_t jj=0;jj<Nj;jj++)
		  for(size_t kk=0;kk<Nk;kk++)
		    for(size_t ll=0;ll<Nl;ll++)
		      bel+=Pbik(ii,kk)*Pbjl(jj,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
	      
	      // Set the element
	      Kaforce(idx)=K1fac*ael;
	      Kbforce(idx)=K1fac*bel;
	      
	      if(K2fac!=0.0) {
		ael=0.0;
		for(size_t ii=0;ii<Ni;ii++) 
		  for(size_t jj=0;jj<Nj;jj++)
		    for(size_t kk=0;kk<Nk;kk++)
		      for(size_t ll=0;ll<Nl;ll++)
			ael+=Pajk(jj,kk)*Pail(ii,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];

		bel=0.0;
		for(size_t ii=0;ii<Ni;ii++) 
		  for(size_t jj=0;jj<Nj;jj++)
		    for(size_t kk=0;kk<Nk;kk++)
		      for(size_t ll=0;ll<Nl;ll++)
			bel+=Pbjk(jj,kk)*Pbil(ii,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
		
		// Increment the element
		Kaforce(idx)+=K2fac*ael;
		Kbforce(idx)+=K2fac*bel;
	      }
	    }
#endif
	  } // End loop over idx
  
	  
	  // Increment forces on atoms
#ifdef DO_J
#ifdef _OPENMP
	  fJwrk.subvec(3*inuc,3*inuc+2)+=Jforce.subvec(0,2);
	  fJwrk.subvec(3*jnuc,3*jnuc+2)+=Jforce.subvec(3,5);
	  fJwrk.subvec(3*knuc,3*knuc+2)+=Jforce.subvec(6,8);
	  fJwrk.subvec(3*lnuc,3*lnuc+2)+=Jforce.subvec(9,11);
#else
	  fJ.subvec(3*inuc,3*inuc+2)+=Jforce.subvec(0,2);
	  fJ.subvec(3*jnuc,3*jnuc+2)+=Jforce.subvec(3,5);
	  fJ.subvec(3*knuc,3*knuc+2)+=Jforce.subvec(6,8);
	  fJ.subvec(3*lnuc,3*lnuc+2)+=Jforce.subvec(9,11);
#endif
#endif


#ifdef DO_K
#ifdef _OPENMP
	  fKwrk.subvec(3*inuc,3*inuc+2)+=Kforce.subvec(0,2);
	  fKwrk.subvec(3*jnuc,3*jnuc+2)+=Kforce.subvec(3,5);
	  fKwrk.subvec(3*knuc,3*knuc+2)+=Kforce.subvec(6,8);
	  fKwrk.subvec(3*lnuc,3*lnuc+2)+=Kforce.subvec(9,11);
#else
	  fK.subvec(3*inuc,3*inuc+2)+=Kforce.subvec(0,2);
	  fK.subvec(3*jnuc,3*jnuc+2)+=Kforce.subvec(3,5);
	  fK.subvec(3*knuc,3*knuc+2)+=Kforce.subvec(6,8);
	  fK.subvec(3*lnuc,3*lnuc+2)+=Kforce.subvec(9,11);
#endif
#endif

#ifdef DO_Kab
#ifdef _OPENMP
	  fKawrk.subvec(3*inuc,3*inuc+2)+=Kaforce.subvec(0,2);
	  fKawrk.subvec(3*jnuc,3*jnuc+2)+=Kaforce.subvec(3,5);
	  fKawrk.subvec(3*knuc,3*knuc+2)+=Kaforce.subvec(6,8);
	  fKawrk.subvec(3*lnuc,3*lnuc+2)+=Kaforce.subvec(9,11);

	  fKbwrk.subvec(3*inuc,3*inuc+2)+=Kbforce.subvec(0,2);
	  fKbwrk.subvec(3*jnuc,3*jnuc+2)+=Kbforce.subvec(3,5);
	  fKbwrk.subvec(3*knuc,3*knuc+2)+=Kbforce.subvec(6,8);
	  fKbwrk.subvec(3*lnuc,3*lnuc+2)+=Kbforce.subvec(9,11);
#else
	  fKa.subvec(3*inuc,3*inuc+2)+=Kaforce.subvec(0,2);
	  fKa.subvec(3*jnuc,3*jnuc+2)+=Kaforce.subvec(3,5);
	  fKa.subvec(3*knuc,3*knuc+2)+=Kaforce.subvec(6,8);
	  fKa.subvec(3*lnuc,3*lnuc+2)+=Kaforce.subvec(9,11);

	  fKb.subvec(3*inuc,3*inuc+2)+=Kbforce.subvec(0,2);
	  fKb.subvec(3*jnuc,3*jnuc+2)+=Kbforce.subvec(3,5);
	  fKb.subvec(3*knuc,3*knuc+2)+=Kbforce.subvec(6,8);
	  fKb.subvec(3*lnuc,3*lnuc+2)+=Kbforce.subvec(9,11);
#endif
#endif


#endif // FORCE
	
	
	} // End loop over jp pairs
      } // End loop over ip pairs

      // Collect results
#ifdef DO_J
#ifdef _OPENMP
#pragma omp critical
#endif
      {
#ifndef FORCE
	J+=Jwrk;
#else
	fJ+=fJwrk;
#endif
      }
#endif

#ifdef DO_K
#ifdef _OPENMP
#pragma omp critical
#endif
      {
#ifndef FORCE
	K+=Kwrk;
#else
	fK+=fKwrk;
#endif
      }
#endif

#ifdef DO_Kab
#ifdef _OPENMP
#pragma omp critical
#endif
      {
#ifndef FORCE
	Ka+=Kawrk;
	Kb+=Kbwrk;
#else
	fKa+=fKawrk;
	fKb+=fKbwrk;
#endif
      }
#endif
      
#ifndef FORCE
      delete eri;
#else
      delete deri;
#endif
    } // end parallel region

#ifndef ERITABLE
  // Compute screening efficiency
  //  printf("Computed %lu shells, skipped %lu due to small absolute value and %lu due to small product.\n",calcd,intskip,denskip);

  if(eff!=NULL) {
    *eff=calcd*100.0/(calcd+intskip+denskip);
  }
#endif

#ifdef CALCJ
#ifndef FORCE
  return J;
#else
  return fJ;
#endif
#elif defined(CALCK)
#ifndef FORCE
  return K;
#else
  return fK;
#endif
#endif
}
