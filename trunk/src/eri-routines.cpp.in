/*
  Routines for computing ERIs. The same algorithm is used both for
  conventional and direct calculations.
*/

/* Function definitions */

#if defined(ERITABLE) && defined(STRICT)
void ERItable::fill(const BasisSet * basp) {
#endif
#if defined(ERITABLE) && !defined(STRICT)
void ERItable::fill(double tol, const BasisSet * basp) {
#endif

#if defined(ERITABLE)
    // Don't do anything with a dummy argument.
    if(basp==NULL)
      return;
#endif

#if defined(CALCJKab) && !defined(STRICT)
void ERIscreen::calcJK(const arma::mat & Pa, const arma::mat & Pb, arma::mat & J, arma::mat & Ka, arma::mat & Kb, double tol, double *eff) const {
#endif
#if defined(CALCJKab) && defined(STRICT)
void ERIscreen::calcJK_strict(const arma::mat & Pa, const arma::mat & Pb, arma::mat & J, arma::mat & Ka, arma::mat & Kb, double tol, double *eff) const {
#endif
#if defined(CALCJKab)
  // Compute total density for Coulomb matrix
  arma::mat P=Pa+Pb;
#endif


#if defined(CALCJK) && !defined(STRICT)
void ERIscreen::calcJK(const arma::mat & P, arma::mat & J, arma::mat & K, double tol, double *eff) const {
#endif
#if defined(CALCJK) && defined(STRICT)
void ERIscreen::calcJK_strict(const arma::mat & P, arma::mat & J, arma::mat & K, double tol, double *eff) const {
#endif


#if defined(CALCK) && !defined(STRICT)
arma::mat ERIscreen::calcK(const arma::mat & P, double tol, double *eff) const {
#endif
#if defined(CALCK) && defined(STRICT)
arma::mat ERIscreen::calcK_strict(const arma::mat & P, double tol, double *eff) const {
#endif
#if defined(CALCK)
  arma::mat K;
#endif

#if defined(CALCJ) && !defined(STRICT)
arma::mat ERIscreen::calcJ(const arma::mat & P, double tol, double *eff) const {
#endif
#if defined(CALCJ) && defined(STRICT)
arma::mat ERIscreen::calcJ_strict(const arma::mat & P, double tol, double *eff) const {
#endif
#if defined(CALCJ)
  arma::mat J;
#endif

  
  // Amount of basis functions
  size_t Nbf=basp->get_Nbf();
  
  /* Check sizes of input */
  
#if defined(CALCK) || defined(CALCJK)
  MAT_SIZE_CHECK(P,Nbf,Nbf,"P is not square!\n");
#endif
  
#if defined(CALCJKab)
  MAT_SIZE_CHECK(Pa,Nbf,Nbf,"Pa is not square!\n");
  MAT_SIZE_CHECK(Pb,Nbf,Nbf,"Pb is not square!\n");
#endif
  
  /* Check size of output */
#if defined(CALCJ) || defined(CALCJK) || defined(CALCJKab)
  MAT_RESIZE(J,Nbf,Nbf);
  J.zeros();
#endif
  
#if defined(CALCK) || defined(CALCJK)
  MAT_RESIZE(K,Nbf,Nbf);
  K.zeros();
#endif
  
#if defined(CALCJKab)
  MAT_RESIZE(Ka,Nbf,Nbf);
  MAT_RESIZE(Kb,Nbf,Nbf);
  Ka.zeros();
  Kb.zeros(); 
#endif
  
  /* Allocate memory for table of integrals */
  
#ifdef ERITABLE
  // Make index helper
  iidx=i_idx(Nbf*(Nbf+1)/2);
  // Make pairs helper
  for(size_t i=0;i<Nbf;i++)
    for(size_t j=0;j<=i;j++) {
      bfpair_t tmp;
      tmp.i=i;
      tmp.j=j;
      pairs.push_back(tmp);
    }
  
  // Compute memory requirements
  size_t N;
  N=N_ints(basp);
  
  // Don't do DOS
  if(N*sizeof(double)>2*1e9) {
    ERROR_INFO();
    throw std::out_of_range("Cowardly refusing to allocate more than two gigs of memory.\n");
  }
  
  try {
    ints.reserve(N);
    ints.resize(N);
  }
  catch(std::bad_alloc err) {
    std::ostringstream oss;
    
    ERROR_INFO();
    oss << "Was unable to reserve " << memory_size(N*sizeof(double)) << " of memory.\n";
    throw std::runtime_error(oss.str());
  }
#else
  // Number of calculated and skipped integrals
  size_t intskip=0, denskip=0, calcd=0;
#endif
  
  /* The filling algorithm may seem a bit complicated. This is because the ERIs
     are computed on a shell basis, and because the same algorithm is used here
     to form the ERIs as for direct calculations.
     
     In order to determine if the filling algorithm works perfectly, there is
     the CHECKFILL option to count the number each integral has been
     calculated.
  */
  
#ifdef CHECKFILL
  // Debug number of accesses
  printf("Allocating memory for checking table.\n");
  
#ifndef ERITABLE
  // Number of integrals is 
  size_t N=Nbf*(Nbf+1)*(Nbf*Nbf+Nbf+2)/8;
#endif
  std::vector<short int> nacc(N);
  for(size_t i=0;i<N;i++)
    nacc[i]=0;
#endif
  
  
  // Get list of unique shell pairs
  std::vector<shellpair_t> shpairs=basp->get_unique_shellpairs();
  // Get number of shell pairs
  const size_t Npairs=shpairs.size();
  
#if !defined(STRICT) && !defined(ERITABLE)
  const size_t Nsh=basp->get_Nshells();
  arma::mat Psh(Nsh,Nsh);
  Psh.zeros();
  
  // Collect maximum density
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(size_t ip=0;ip<Npairs;ip++) {
    // Shells are
    size_t is=shpairs[ip].is;
    size_t js=shpairs[ip].js;
    // First functions on shells are
    size_t i0=basp->get_first_ind(is);
    size_t j0=basp->get_first_ind(js);
    // Indices of last functions on shells
    size_t ilast=basp->get_last_ind(is);
    size_t jlast=basp->get_last_ind(js);
    
    // Maximum value of density is
    Psh(is,js)=max_abs(P.submat(i0,j0,ilast,jlast));
    Psh(js,is)=Psh(is,js);
  }
#endif
  
  
  
#if defined(ERITABLE) && !defined(STRICT)
  // Form screening matrix
  const size_t Nsh=basp->get_Nshells();
  arma::mat screen(Nsh,Nsh);
  
  // Loop over shell pairs
#ifdef _OPENMP
#pragma omp parallel for schedule(dynamic,1)
#endif
  for(size_t ip=0;ip<Npairs;ip++) {
    size_t i=shpairs[ip].is;
    size_t j=shpairs[ip].js;
    
    // Compute integrals
    std::vector<double> tmp=basp->ERI(i,j,i,j);
    // Get maximum value
    double m=0.0;
    for(size_t k=0;k<tmp.size();k++)
      if(fabs(tmp[k])>m)
	m=fabs(tmp[k]);
    m=sqrt(m);
    screen(i,j)=m;
    screen(j,i)=m;
  }
#endif
  
  // Loop over first pairs
#ifdef _OPENMP
  
#ifdef ERITABLE
#pragma omp parallel
#else
#pragma omp parallel reduction(+:calcd,intskip,denskip)
#endif
 
#endif // ifdef _OPENMP
  {
    
#ifndef ERITABLE
    // Arrays of identical integrals
    size_t iarr[8], jarr[8], karr[8], larr[8];
    size_t nid; // Number of identical integrals in this batch
#endif
    
#if !defined(ERITABLE) && defined(_OPENMP)
    const arma::mat Pwrk=P;
#if !defined(STRICT)
    const arma::mat Pshwrk=Psh;
#endif
#endif
#if defined(CALCJKab) && defined(_OPENMP)
    const arma::mat Pawrk=Pa;
    const arma::mat Pbwrk=Pb;
#endif
    
#if defined(_OPENMP) && !defined(ERITABLE) && !defined(CALCK)
    arma::mat Jwrk(Nbf,Nbf);
    Jwrk.zeros();
#endif
    
#if defined(_OPENMP) && (defined(CALCK) || defined(CALCJK))
    arma::mat Kwrk(Nbf,Nbf);
    Kwrk.zeros();
#endif
    
#if defined(_OPENMP) && defined(CALCJKab)
    arma::mat Kawrk(Nbf,Nbf);
    Kawrk.zeros();
    
    arma::mat Kbwrk(Nbf,Nbf);
    Kbwrk.zeros();
#endif
    
    
#ifdef _OPENMP
#pragma omp for schedule(dynamic)
#endif
    for(size_t ip=0;ip<Npairs;ip++) {
      // Loop over second pairs
      for(size_t jp=0;jp<=ip;jp++) {
	
	// Shells on second pair are
	size_t ks=shpairs[ip].is;
	size_t ls=shpairs[ip].js;
	// and those on the first pair
	size_t is=shpairs[jp].is;
	size_t js=shpairs[jp].js;
	
	// First functions on shells are
	size_t k0=basp->get_first_ind(ks);
	size_t l0=basp->get_first_ind(ls);
	// and on the first pair
	size_t i0=basp->get_first_ind(is);
	size_t j0=basp->get_first_ind(js);
	
	// Amount of functions on the second pair
	size_t Nk=basp->get_Nbf(ks);
	size_t Nl=basp->get_Nbf(ls);
	// and on the first pair
	size_t Ni=basp->get_Nbf(is);
	size_t Nj=basp->get_Nbf(js);
	
	
	/* Perform screening of integrals */
#if !(defined(ERITABLE) && defined(STRICT))
	// Maximum value of the 2-electron integrals on this shell pair
	double intmax=screen(is,js)*screen(ks,ls);
#endif
	
#if defined(ERITABLE) && !defined(STRICT)
	// Skip calculation of integrals, and just fill in zeros?
	bool skip=false;
	if(intmax<tol)
	  skip=true;
#endif
	
	
#if !defined(ERITABLE)
	if(intmax<tol) {
	  // Skip integral due to small value of integral
	  intskip++;
	  continue;
	}
#if defined(STRICT)
	else calcd++;
#else
	else {
	  // Compute maximum density
	  arma::vec Pv(6);
	  Pv.zeros();
#ifdef _OPENMP
	  Pv(0)=Pshwrk(is,js);
	  Pv(1)=Pshwrk(is,ks);
	  Pv(2)=Pshwrk(is,ls);
	  Pv(3)=Pshwrk(js,ks);
	  Pv(4)=Pshwrk(js,ls);
	  Pv(5)=Pshwrk(ks,ls);
#else
	  Pv(0)=Psh(is,js);
	  Pv(1)=Psh(is,ks);
	  Pv(2)=Psh(is,ls);
	  Pv(3)=Psh(js,ks);
	  Pv(4)=Psh(js,ls);
	  Pv(5)=Psh(ks,ls);
#endif // _OPENMP
	  double maxP=max(Pv);
	  
	  if(maxP*intmax<tol) {
	    // Skip integral due to small product of density and integral
	    denskip++;
	    continue;
	  }
	  else

	    // Need to calculate integral.
	    calcd++;
	}
#endif // ifdef STRICT
#endif // ifdef ERITABLE
	  
	
	// Compute integrals
	std::vector<double> tmp;
#if defined(ERITABLE) && !defined(STRICT)
	// Screening for ERITABLE
	if(!skip)
	  tmp=basp->ERI(is,js,ks,ls);
	else {
	  tmp.reserve(Ni*Nj*Nk*Nl);
	  tmp.insert(tmp.begin(),Ni*Nj*Nk*Nl,0.0);
	}
#else
	tmp=basp->ERI(is,js,ks,ls);
#endif
	
	
	/*
	  printf("\nShells (%i %i | %i %i)\n",is,js,ks,ls);
	  printf("Integrals are:");
	  for(size_t in=0;in<tmp.size();in++)
	  printf(" % e",tmp[in]);
	  printf("\n");
	*/
	
	/* Fill table, or increment matrices */
	{
	  // Helpers
	  size_t i, j, k, l;
	  size_t iimax, jjmax, kkmax, llmax;
	  
	  if(is==js && ks==ls && is==ks) {
	    // All shells are the same: (is is | is is)
	    
	    iimax=Ni-1;
	    for(size_t ii=0;ii<=iimax;ii++) {
	      i=i0+ii;
	      
	      jjmax=ii;
	      for(size_t jj=0;jj<=jjmax;jj++) {
		j=j0+jj;
		
		kkmax=ii;
		for(size_t kk=0;kk<=kkmax;kk++) {
		  k=k0+kk;
		  
		  // jj if kk and ii are same, otherwise kk
		  llmax = (kk==ii) ? jj : kk ; 
		  for(size_t ll=0;ll<=llmax;ll++) {
		    l=l0+ll;
		    
		    // Store integral or increment matrices
#include "eri-routines-increment.cpp.in"
		    
		  }
		}
	      }
	    }
	  } else if(is==ks && js==ls) {
	    // Two shells are the same: (is js | is js)
	    
	    iimax=Ni-1;
	    jjmax=Nj-1;
	    
	    for(size_t ii=0;ii<=iimax;ii++) {
	      i=i0+ii;
	      for(size_t jj=0;jj<=jjmax;jj++) {
		j=j0+jj;
		
		kkmax=ii;
		for(size_t kk=0;kk<=kkmax;kk++) {
		  k=k0+kk;
		  
		  llmax = (kk==ii) ? jj : Nl-1 ;
		  for(size_t ll=0;ll<=llmax;ll++) {
		    l=l0+ll;
		    
		    // Store integral or increment matrices
#include "eri-routines-increment.cpp.in"
		    
		  }
		}
	      }
	    }
	  } else {
	    // (is js | ks ls) case
	    
	    iimax=Ni-1;
	    kkmax=Nk-1;
	    for(size_t ii=0;ii<=iimax;ii++) {
	      i=i0+ii;
	      
	      jjmax= (is==js) ? ii : Nj-1;
	      for(size_t jj=0;jj<=jjmax;jj++) {
		j=j0+jj;
		
		for(size_t kk=0;kk<=kkmax;kk++) {
		  k=k0+kk;
		  
		  llmax = (ks==ls) ? kk : Nl-1 ;
		  for(size_t ll=0;ll<=llmax;ll++) {
		    l=l0+ll;
		    
		    // Store integral or increment matrices
#include "eri-routines-increment.cpp.in"
		    
		  }
		}
	      }
	    }
	  }
	} // end table filling / matrix incrementation
      } // End loop over jp pairs
    } // End loop over ip pairs 
  
      // Collect results
#if defined(_OPENMP)
    
#if !defined(CALCK) && !defined(ERITABLE)
#pragma omp critical
    J+=Jwrk;
#endif
    
#if defined(CALCK) || defined(CALCJK)
#pragma omp critical
    K+=Kwrk;
#endif
    
#ifdef CALCJKab
#pragma omp critical
    {
      Ka+=Kawrk;
      Kb+=Kbwrk;
    }
#endif
    
#endif // end collection
    
  } // end parallel region
  
#ifdef CHECKFILL  
  size_t ndupl=0, nmiss=0;
  bool print;
  for(size_t i=0;i<N;i++) {
    print=0;
    if(nacc[i]==0) {
      printf("Integral %i has not been calculated.\n",(int) i);
      nmiss++;
      print=1;
    } else if(nacc[i]>1) {
      printf("Integral %i has been calculated %i times.\n",(int) i,nacc[i]);
      ndupl++;
      print=1;
    }
    if(print) {
      // Find out index
      bool found=0;
      for(size_t ii=0;ii<Nbf;ii++) {
	for(size_t jj=0;jj<Nbf;jj++) {
	  for(size_t kk=0;kk<Nbf;kk++) {
	    for(size_t ll=0;ll<Nbf;ll++) {
	      
	      if(i==idx(ii,jj,kk,ll)) {
		printf("It is %i %i %i %i.\n",ii,jj,kk,ll);
		found=1;
		break;
	      }
	    }
	    
	    if(found)
	      break;
	  }
	  if(found)
	    break;
	}
	if(found)
	  break;
      }
      
    }
  }
  
  printf("%lu are missing and %lu are duplicates.\n", nmiss, ndupl);
#endif
  
#ifndef ERITABLE
  // Compute screening efficiency
  //  printf("Computed %lu shells, skipped %lu due to small absolute value and %lu due to small product.\n",calcd,intskip,denskip);
  
  if(eff!=NULL) {
    *eff=calcd*100.0/(calcd+intskip+denskip);
  }
#endif
  
#ifdef CALCJ
  return J;
#elif defined(CALCK)
  return K;
#endif
}
 
 
