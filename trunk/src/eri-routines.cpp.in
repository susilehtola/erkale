/*
  Routines for computing ERIs. The same algorithm is used both for
  conventional and direct calculations.
*/

/* Function definitions */

#ifdef ERITABLE
void ERItable::fill(const BasisSet * basp) {
// Don't do anything with a dummy argument.
  if(basp==NULL)
    return;
#else

#if defined(CALCJKab)
void ERIscreen::calcJK(const arma::mat & Ra, const arma::mat & Rb, arma::mat & J, arma::mat & Ka, arma::mat & Kb, double tol, double *eff) const {
// Compute total density for Coulomb matrix
  arma::mat R=Ra+Rb;
#elif defined(CALCJK)
void ERIscreen::calcJK(const arma::mat & R, arma::mat & J, arma::mat & K, double tol, double *eff) const {
#elif defined(CALCK)
arma::mat ERIscreen::calcK(const arma::mat & R, double tol, double *eff) const {
  arma::mat K;
#else
arma::mat ERIscreen::calcJ(const arma::mat & R, double tol, double *eff) const {
  arma::mat J;
#endif // if defined(CALCJKab)

#endif // ifdef ERITABLE

  // Amount of basis functions
  size_t Nbf=basp->get_Nbf();

  /* Check sizes of input */

#if defined(CALCK) || defined(CALCJK)
  MAT_SIZE_CHECK(R,Nbf,Nbf,"R is not square!\n");
#endif

#if defined(CALCJKab)
  MAT_SIZE_CHECK(Ra,Nbf,Nbf,"Ra is not square!\n");
  MAT_SIZE_CHECK(Rb,Nbf,Nbf,"Rb is not square!\n");
#endif

  /* Check size of output */
#ifndef ERITABLE

#ifndef CALCK
  MAT_RESIZE(J,Nbf,Nbf);
  J.zeros();
#endif

#if defined(CALCK) || defined(CALCJK)
  MAT_RESIZE(K,Nbf,Nbf);
  K.zeros();
#endif

#if defined(CALCJKab)
  MAT_RESIZE(Ka,Nbf,Nbf);
  MAT_RESIZE(Kb,Nbf,Nbf);
  Ka.zeros();
  Kb.zeros(); 
#endif

  /* Allocate worker memory */
#ifdef _OPENMP
  // Get (maximum) number of threads
  int nth=omp_get_max_threads();

#ifndef CALCK
  std::vector<arma::mat> Jwrk;
  for(int i=0;i<nth;i++) {
    arma::mat zeros(Nbf,Nbf);
    zeros.zeros();
    Jwrk.push_back(zeros);
  }
#endif

#if defined(CALCK) || defined(CALCJK)
  std::vector<arma::mat> Kwrk;
  for(int i=0;i<nth;i++) {
    arma::mat zeros(Nbf,Nbf);
    zeros.zeros();
    Kwrk.push_back(zeros);
  }
#endif

#ifdef CALCJKab
  std::vector<arma::mat> Kawrk, Kbwrk;
  for(int i=0;i<nth;i++) {
    arma::mat zeros(Nbf,Nbf);
    zeros.zeros();
    Kawrk.push_back(zeros);
    Kbwrk.push_back(zeros);
  }
#endif

#endif // ifdef _OPENMP

#endif // ifndef ERITABLE

  /* Allocate memory for table of integrals */

#ifdef ERITABLE
  // Make index helper
  iidx=i_idx(Nbf*(Nbf+1)/2);
  // Make pairs helper
  for(size_t i=0;i<Nbf;i++)
    for(size_t j=0;j<=i;j++) {
      bfpair_t tmp;
      tmp.i=i;
      tmp.j=j;
      pairs.push_back(tmp);
    }
  
  // Compute memory requirements
  size_t N;
  N=N_ints(basp);

  // Don't do DOS
  if(N*sizeof(double)>2*1e9) {
    ERROR_INFO();
    throw std::out_of_range("Cowardly refusing to allocate more than two gigs of memory.\n");
  }

  try {
    ints.reserve(N);
    ints.resize(N);
  }
  catch(std::bad_alloc err) {
    std::ostringstream oss;

    ERROR_INFO();
    oss << "Was unable to reserve " << memory_size(N*sizeof(double)) << " of memory.\n";
    throw std::runtime_error(oss.str());
  }
#else
  // Number of calculated and skipped integrals
  size_t intskip=0, denskip=0, calcd=0;
#endif

  /* The filling algorithm may seem a bit complicated. This is because the ERIs
     are computed on a shell basis, and because the same algorithm is used here
     to form the ERIs as for direct calculations.

     In order to determine if the filling algorithm works perfectly, there is
     the CHECKFILL option to count the number each integral has been
     calculated.
  */

#ifdef CHECKFILL
  // Debug number of accesses
  printf("Allocating memory for checking table.\n");

#ifndef ERITABLE
  // Number of integrals is 
  size_t N=Nbf*(Nbf+1)*(Nbf*Nbf+Nbf+2)/8;
#endif
  std::vector<short int> nacc(N);
  for(size_t i=0;i<N;i++)
    nacc[i]=0;

#endif

  // Get list of unique shell pairs
  std::vector<shellpair_t> pairs=basp->get_unique_shellpairs();
  // Get number of shell pairs
  const size_t Npairs=pairs.size();


  // Loop over first pairs
#ifdef _OPENMP

#ifdef ERITABLE
#pragma omp parallel
#else
#pragma omp parallel reduction(+:calcd,intskip,denskip)
#endif

#endif // ifdef _OPENMP
  {

#ifndef ERITABLE
    // Arrays of identical integrals
    size_t iarr[8], jarr[8], karr[8], larr[8];
    size_t nid; // Number of identical integrals in this batch
#endif

#ifdef _OPENMP

#ifndef ERITABLE
    int thid=omp_get_thread_num();
#endif

#pragma omp for schedule(dynamic)
#endif // ifdef _OPENMP
    for(size_t ip=0;ip<Npairs;ip++) {
      // Loop over second pairs
      for(size_t jp=0;jp<=ip;jp++) {

	// Shells on first pair are
	size_t ks=pairs[ip].is;
	size_t ls=pairs[ip].js;
	// First functions on shells are
	size_t k0=basp->get_first_ind(ks);
	size_t l0=basp->get_first_ind(ls);
	// and amounts of functions on shells are
	size_t Nk=basp->get_Nbf(ks);
	size_t Nl=basp->get_Nbf(ls);
	
#ifndef ERITABLE
	// Indices of last functions on shells
	size_t klast=basp->get_last_ind(ks);
	size_t llast=basp->get_last_ind(ls);
#endif
      
	// Shells on second pair are
	size_t is=pairs[jp].is;
	size_t js=pairs[jp].js;
	// First functions on shells are
	size_t i0=basp->get_first_ind(is);
	size_t j0=basp->get_first_ind(js);
	// and amounts of functions on shells are
	size_t Ni=basp->get_Nbf(is);
	size_t Nj=basp->get_Nbf(js);
	
#ifndef ERITABLE
	// Indices of last functions on shells
	size_t ilast=basp->get_last_ind(is);
	size_t jlast=basp->get_last_ind(js);
#endif
	
	/* Perform screening of integrals */
#ifndef ERITABLE
	// Maximum value of the 2-electron integrals on this shell pair
	double intmax=screen(is,js)*screen(ks,ls);
	
	if(intmax<tol) {
	  // Skip integral due to small value of integral
	  intskip++;
	  continue;
	  
	} else {
	  // Compute maximum density
	  
	  // Maximum value of density
	  double maxR, maxR_arr[6], maxR_red[2];
	  maxR_arr[0]=max_abs(R.submat(i0,j0,ilast,jlast));
	  maxR_arr[1]=max_abs(R.submat(i0,k0,ilast,klast));
	  maxR_arr[2]=max_abs(R.submat(i0,l0,ilast,llast));
	  maxR_arr[3]=max_abs(R.submat(j0,k0,jlast,klast));
	  maxR_arr[4]=max_abs(R.submat(j0,l0,jlast,llast));
	  maxR_arr[5]=max_abs(R.submat(k0,l0,klast,llast));
	  
	  maxR_red[0]=max4(maxR_arr[0],maxR_arr[1],maxR_arr[2],maxR_arr[3]);
	  maxR_red[1]=std::max(maxR_arr[4],maxR_arr[5]);
	  maxR=std::max(maxR_red[0],maxR_red[1]);
	  
	  if(maxR*intmax<tol) {
	    // Skip integral due to small product of density and integral
	    denskip++;
	    continue;
	  } else
	    // Need to calculate integral.
	    calcd++;
	}
#endif
	
	// Compute integrals
	std::vector<double> tmp=basp->ERI(is,js,ks,ls);
#ifdef _OPENMP
	//	printf("Thread %i computed (%i %i %i %i)\n",omp_get_thread_num(),is,js,ks,ls);
#endif
	
	
	/*
	  printf("\nShells (%i %i | %i %i)\n",is,js,ks,ls);
	  printf("Integrals are:");
	  for(size_t in=0;in<tmp.size();in++)
	  printf(" % e",tmp[in]);
	  printf("\n");
	*/

	/* Fill table, or increment matrices */
	{
	  // Helpers
	  size_t i, j, k, l;
	  size_t iimax, jjmax, kkmax, llmax;
	  
	  if(is==js && ks==ls && is==ks) {
	    // All shells are the same: (is is | is is)
	    
	    iimax=Ni-1;
	    for(size_t ii=0;ii<=iimax;ii++) {
	      i=i0+ii;
	      
	      jjmax=ii;
	      for(size_t jj=0;jj<=jjmax;jj++) {
		j=j0+jj;
		
		kkmax=ii;
		for(size_t kk=0;kk<=kkmax;kk++) {
		  k=k0+kk;
		  
		  // jj if kk and ii are same, otherwise kk
		  llmax = (kk==ii) ? jj : kk ; 
		  for(size_t ll=0;ll<=llmax;ll++) {
		    l=l0+ll;
		    
		    // Store integral or increment matrices
#include "eri-routines-increment.cpp.in"
		    
		  }
		}
	      }
	    }
	  } else if(is==ks && js==ls) {
	    // Two shells are the same: (is js | is js)
	    
	    iimax=Ni-1;
	    jjmax=Nj-1;
	    
	    for(size_t ii=0;ii<=iimax;ii++) {
	      i=i0+ii;
	      for(size_t jj=0;jj<=jjmax;jj++) {
		j=j0+jj;
		
		kkmax=ii;
		for(size_t kk=0;kk<=kkmax;kk++) {
		  k=k0+kk;
		  
		  llmax = (kk==ii) ? jj : Nl-1 ;
		  for(size_t ll=0;ll<=llmax;ll++) {
		    l=l0+ll;
		    
		    // Store integral or increment matrices
#include "eri-routines-increment.cpp.in"
		    
		  }
		}
	      }
	    }
	  } else {
	    // (is js | ks ls) case
	    
	    iimax=Ni-1;
	    kkmax=Nk-1;
	    for(size_t ii=0;ii<=iimax;ii++) {
	      i=i0+ii;
	      
	      jjmax= (is==js) ? ii : Nj-1;
	      for(size_t jj=0;jj<=jjmax;jj++) {
		j=j0+jj;
		
		for(size_t kk=0;kk<=kkmax;kk++) {
		  k=k0+kk;
		  
		  llmax = (ks==ls) ? kk : Nl-1 ;
		  for(size_t ll=0;ll<=llmax;ll++) {
		    l=l0+ll;
		    
		    // Store integral or increment matrices
#include "eri-routines-increment.cpp.in"
		    
		  }
		}
	      }
	    }
	  }
	} // end critical region
      }
    }
  } // end parallel region

  /* Sum results together */
#if defined(_OPENMP) && !defined(ERITABLE)

#ifndef CALCK
  for(int i=0;i<nth;i++) {
    J+=Jwrk[i];
  }
#endif

#if defined(CALCK) || defined(CALCJK)
  for(int i=0;i<nth;i++) {
    K+=Kwrk[i];
  }
#endif

#ifdef CALCJKab
  for(int i=0;i<nth;i++) {
    Ka+=Kawrk[i];
    Kb+=Kbwrk[i];
  }
#endif

#endif

  
#ifdef CHECKFILL  
  size_t ndupl=0, nmiss=0;
  bool print;
  for(size_t i=0;i<N;i++) {
    print=0;
    if(nacc[i]==0) {
      printf("Integral %i has not been calculated.\n",(int) i);
      nmiss++;
      print=1;
    } else if(nacc[i]>1) {
      printf("Integral %i has been calculated %i times.\n",(int) i,nacc[i]);
      ndupl++;
      print=1;
    }
    if(print) {
      // Find out index
      bool found=0;
      for(size_t ii=0;ii<Nbf;ii++) {
	for(size_t jj=0;jj<Nbf;jj++) {
	  for(size_t kk=0;kk<Nbf;kk++) {
	    for(size_t ll=0;ll<Nbf;ll++) {
	      
	      if(i==idx(ii,jj,kk,ll)) {
		printf("It is %i %i %i %i.\n",ii,jj,kk,ll);
		found=1;
		break;
	      }
	    }
	    
	    if(found)
	      break;
	  }
	  if(found)
	    break;
	}
	if(found)
	  break;
      }
      
    }
  }
  
  printf("%lu are missing and %lu are duplicates.\n", nmiss, ndupl);
#endif

#ifndef ERITABLE
  // Compute screening efficiency
  //  printf("Computed %lu shells, skipped %lu due to small absolute value and %lu due to small product.\n",calcd,intskip,denskip);

  if(eff!=NULL) {
    *eff=calcd*100.0/(calcd+intskip+denskip);
  }
#endif

#ifdef CALCJ
  return J;
#elif defined(CALCK)
  return K;
#endif
}
