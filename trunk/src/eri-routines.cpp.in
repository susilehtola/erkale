/*
 *                This source code is part of
 * 
 *                     E  R  K  A  L  E
 *                             -
 *                       DFT from Hel
 *
 * Written by Susi Lehtola, 2010-2013
 * Copyright (c) 2010-2013, Susi Lehtola
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 */

/*
  Routines for computing ERIs. The same algorithm is used both for
  conventional and direct calculations.
*/

/* Function definitions */
#include "eri_digest.h"

#if defined(ERITABLE)
size_t ERItable::fill(const BasisSet * basp, double tol) {
#endif

#if defined(CALCJKab)
#ifndef FORCE
void ERIscreen::calcJK(const arma::mat & Pa, const arma::mat & Pb, arma::mat & J, arma::mat & Ka, arma::mat & Kb, double tol) const
#else
void ERIscreen::forceJK(const arma::mat & Pa, const arma::mat & Pb, arma::vec & fJ, arma::vec & fKa, arma::vec & fKb, double tol) const
#endif
{
  // Compute total density for Coulomb matrix
  arma::mat P=Pa+Pb;
#endif

#if defined(CALCKab)
#ifndef FORCE
void ERIscreen::calcK(const arma::mat & Pa, const arma::mat & Pb, arma::mat & Ka, arma::mat & Kb, double tol) const
#else
void ERIscreen::forceK(const arma::mat & Pa, const arma::mat & Pb, arma::vec & fKa, arma::vec & fKb, double tol) const
#endif
{
  // Compute total density for Coulomb matrix
  arma::mat P=Pa+Pb;
#endif


#if defined(CALCJK)
#ifndef FORCE
void ERIscreen::calcJK(const arma::mat & P, arma::mat & J, arma::mat & K, double tol) const {
#else
void ERIscreen::forceJK(const arma::mat & P, arma::vec & fJ, arma::vec & fK, double tol) const {
#endif
#endif

#if defined(CALCK)
#ifndef FORCE
arma::mat ERIscreen::calcK(const arma::mat & P, double tol) const {
  arma::mat K;
#else
arma::vec ERIscreen::forceK(const arma::mat & P, double tol) const {
  arma::vec fK;
#endif
#endif

#if defined(CALCJ)
#ifndef FORCE
arma::mat ERIscreen::calcJ(const arma::mat & P, double tol) const {
  arma::mat J;
#else
arma::vec ERIscreen::forceJ(const arma::mat & P, double tol) const {
  arma::vec fJ;
#endif
#endif

#ifndef ERITABLE
  // Amount of basis functions
  size_t Nbf=basp->get_Nbf();
#endif
  // Shells
  std::vector<GaussianShell> shells=basp->get_shells();

  /* Check sizes of input */
#ifndef FORCE
#if defined(CALCJ) || defined(CALCJK) || defined(CALCJKab)
#define DO_J
  J.zeros(Nbf,Nbf);
#endif
  
#if defined(CALCK) || defined(CALCJK)
#define DO_K
  K.zeros(Nbf,Nbf);
#endif

#if defined(CALCJKab) || defined(CALCKab)
  Ka.zeros(Nbf,Nbf);
  Kb.zeros(Nbf,Nbf);
#endif

#else // FORCE

#if defined(CALCJ) || defined(CALCJK) || defined(CALCJKab)
#define DO_J
  fJ.zeros(3*basp->get_Nnuc());
#endif

#if defined(CALCK) || defined(CALCJK)
#define DO_K
  fK.zeros(3*basp->get_Nnuc());
#endif

#if defined(CALCJKab) || defined(CALCKab)
  fKa.zeros(3*basp->get_Nnuc());
  fKb.zeros(3*basp->get_Nnuc());
#endif
#endif // FORCE


#if defined(CALCJKab) || defined(CALCKab)
#define DO_Kab
  MAT_SIZE_CHECK(Pa,Nbf,Nbf);
  MAT_SIZE_CHECK(Pb,Nbf,Nbf);
#endif

#if defined(DO_J) || defined(DO_K)
  MAT_SIZE_CHECK(P,Nbf,Nbf);
#endif

  /* Allocate memory for table of integrals */
#ifdef ERITABLE
  // Compute memory requirements
  size_t N;
  N=N_ints(basp,tol);
  
  // Don't do DOS
  if(N*sizeof(double)>14*1e9) {
    ERROR_INFO();
    throw std::out_of_range("Cowardly refusing to allocate more than 14 gigs of memory.\n");
  }
  
  try {
    ints.resize(N);
  } catch(std::bad_alloc err) {
    std::ostringstream oss;
    
    ERROR_INFO();
    oss << "Was unable to reserve " << memory_size(N*sizeof(double)) << " of memory.\n";
    throw std::runtime_error(oss.str());
  }
#endif

  // Number of calculated and skipped integrals
  size_t intskip=0, calcd=0;

  /* The filling algorithm may seem a bit complicated. This is because the ERIs
     are computed on a shell basis, and because the same algorithm is used here
     to form the ERIs as for direct calculations.
  */

  // Get number of shell pairs
  const size_t Npairs=shpairs.size();

  // Loop over first pairs
#ifdef _OPENMP
#pragma omp parallel reduction(+:calcd,intskip)
#endif // ifdef _OPENMP
  { // Open parallel region

#ifndef FORCE
    /// ERI worker
    ERIWorker *eri;
#else
    /// ERI worker
    dERIWorker *deri;
#endif
    
#ifndef FORCE
    if(omega==0.0)
      eri=new ERIWorker(basp->get_max_am(),basp->get_max_Ncontr());
    else
      eri=new ERIWorker_srlr(basp->get_max_am(),basp->get_max_Ncontr(),omega,alpha,beta);
#else
    if(omega==0.0)
      deri=new dERIWorker(basp->get_max_am(),basp->get_max_Ncontr());
    else
      deri=new dERIWorker_srlr(basp->get_max_am(),basp->get_max_Ncontr(),omega,alpha,beta);
#endif
    
    /// Integral array
    const std::vector<double> * erip;

#ifndef FORCE
#ifdef DO_J
    arma::mat Jwrk(J);
#endif

#ifdef DO_K
    arma::mat Kwrk(K);
#endif

#ifdef DO_Kab
    arma::mat Kawrk(Ka);
    arma::mat Kbwrk(Kb);
#endif

#else // FORCE

#ifdef DO_J
    arma::vec fJwrk(fJ);
#endif

#ifdef DO_K
    arma::vec fKwrk(fK);
#endif

#ifdef DO_Kab
    arma::vec fKawrk(fKa);
    arma::vec fKbwrk(fKb);
#endif

#endif // FORCE

#ifndef ERITABLE // Can't parallellize since we wouldn't know where to place the integrals...
#ifdef _OPENMP
#pragma omp for schedule(dynamic)
#endif
#endif
    for(size_t ip=0;ip<Npairs;ip++) {
      // Loop over second pairs
      for(size_t jp=0;jp<=ip;jp++) {
	// Shells on first pair
	size_t is=shpairs[ip].is;
	size_t js=shpairs[ip].js;
	// and those on the second pair
	size_t ks=shpairs[jp].is;
	size_t ls=shpairs[jp].js;
	
#ifdef ERITABLE
	// Calculate offset in integrals table
	size_t ioff0(shoff[ip]);
	size_t Nij=shpairs[ip].Ni*shpairs[ip].Nj;
	for(size_t jj=0;jj<jp;jj++)
	  ioff0+=Nij*shpairs[jj].Ni*shpairs[jj].Nj;

	// Amount of functions on the first pair
	size_t Ni=shpairs[ip].Ni;
	size_t Nj=shpairs[ip].Nj;
	// and on the second
	size_t Nk=shpairs[jp].Ni;
	size_t Nl=shpairs[jp].Nj;
	// Initialize table
	{
	  size_t ioff(ioff0);
	  for(size_t fi=0;fi<Ni;fi++)
	    for(size_t fj=0;fj<Nj;fj++)
	      for(size_t fk=0;fk<Nk;fk++)
		for(size_t fl=0;fl<Nl;fl++) {
		  ints[ioff++]=0.0;
		}
	}
#else
#ifdef FORCE
	// Amount of functions on the first pair
	size_t Ni=shpairs[ip].Ni;
	size_t Nj=shpairs[ip].Nj;
	// and on the second
	size_t Nk=shpairs[jp].Ni;
	size_t Nl=shpairs[jp].Nj;
	
	// First functions on shells are
	size_t i0=shpairs[ip].i0;
	size_t j0=shpairs[ip].j0;
	// and on the second pair
	size_t k0=shpairs[jp].i0;
	size_t l0=shpairs[jp].j0;
#endif
#endif
	{
	  // Maximum value of the 2-electron integrals on this shell pair
	  double intmax=screen(is,js)*screen(ks,ls);
	  if(intmax<tol) {
	    // Skip due to small value of integral. Because the
	    // integrals have been ordered, all the next ones will be
	    // small as well!
	    intskip+=is-js+1;
	    break;
	  }
	}
	
	// Increment amount of calculated integrals
	calcd++;

#ifndef FORCE
	// Compute integrals
	eri->compute(&shells[is],&shells[js],&shells[ks],&shells[ls]);
	erip=eri->getp();

#ifdef ERITABLE
	// Store integrals
	for(size_t ii=0;ii<Ni*Nj*Nk*Nl;ii++)
	  ints[ioff0+ii]=(*erip)[ii];
#endif

#ifdef DO_J
	digest_J(shpairs,ip,jp,P,(*erip),0,Jwrk);
#endif

#if defined(DO_K)
        digest_K(shpairs,ip,jp,double,P,(*erip),0,Kwrk);
#endif

#if defined(DO_Kab)
        digest_K(shpairs,ip,jp,double,Pa,(*erip),0,Kawrk);
        digest_K(shpairs,ip,jp,double,Pb,(*erip),0,Kbwrk);
#endif

#else // FORCE

	// Shell centers
	size_t inuc=shells[is].get_center_ind();
	size_t jnuc=shells[js].get_center_ind();
	size_t knuc=shells[ks].get_center_ind();
	size_t lnuc=shells[ls].get_center_ind();

	// Skip when all functions are on the same nucleus
	if(inuc==jnuc && jnuc==knuc && knuc==lnuc)
	  continue;

	// Compute the derivatives.
	deri->compute(&shells[is],&shells[js],&shells[ks],&shells[ls]);

#ifdef DO_J
	  arma::vec Jforce(12);
	  Jforce.zeros();

	  // E_J = P_ij (ij|kl) P_kl. Work matrices
	  arma::mat Pij=P.submat(i0,j0,i0+Ni-1,j0+Nj-1);
	  arma::mat Pkl=P.submat(k0,l0,k0+Nk-1,l0+Nl-1);
	  
	  // Degeneracy factor
	  double Jfac=-0.5;
	  if(is!=js)
	    Jfac*=2.0;
	  if(ks!=ls)
	    Jfac*=2.0;
	  if(ip!=jp)
	    Jfac*=2.0;
#endif

#ifdef DO_K
	  arma::vec Kforce(12);
	  Kforce.zeros();

	  // E_K = P_ik (ij|kl) P_jl
	  arma::mat Pik=P.submat(i0,k0,i0+Ni-1,k0+Nk-1);
	  arma::mat Pjl=P.submat(j0,l0,j0+Nj-1,l0+Nl-1);
	  //     + P_jk (ij|kl) P_il
	  arma::mat Pjk=P.submat(j0,k0,j0+Nj-1,k0+Nk-1);
	  arma::mat Pil=P.submat(i0,l0,i0+Ni-1,l0+Nl-1);
#endif

#ifdef DO_Kab
	  arma::vec Kaforce(12);
	  Kaforce.zeros();
	  arma::vec Kbforce(12);
	  Kbforce.zeros();

	  // E_K = P_ik (ij|kl) P_jl
	  arma::mat Paik=Pa.submat(i0,k0,i0+Ni-1,k0+Nk-1);
	  arma::mat Pbik=Pb.submat(i0,k0,i0+Ni-1,k0+Nk-1);
	  arma::mat Pajl=Pa.submat(j0,l0,j0+Nj-1,l0+Nl-1);
	  arma::mat Pbjl=Pb.submat(j0,l0,j0+Nj-1,l0+Nl-1);
	  //     + P_jk (ij|kl) P_il
	  arma::mat Pajk=Pa.submat(j0,k0,j0+Nj-1,k0+Nk-1);
	  arma::mat Pbjk=Pb.submat(j0,k0,j0+Nj-1,k0+Nk-1);
	  arma::mat Pail=Pa.submat(i0,l0,i0+Ni-1,l0+Nl-1);
	  arma::mat Pbil=Pb.submat(i0,l0,i0+Ni-1,l0+Nl-1);
#endif

#if defined(DO_K) || defined(DO_Kab)
	  double K1fac, K2fac;
	  if(is!=js && ks!=ls) {
	    // Get both twice.
	    K1fac=1.0;
	    K2fac=1.0;
	  } else if(is==js && ks==ls) {
	    // Only get the first one, once.
	    K1fac=0.5;
	    K2fac=0.0;
	  } else {
	    // Get both once.
	    K1fac=0.5;
	    K2fac=0.5;
	  }

	  // Switch symmetry
	  if(ip!=jp) {
	    K1fac*=2.0;
	    K2fac*=2.0;
	  }
	  
#ifdef DO_K
	  // Restricted case - only get half
	  K1fac/=2;
	  K2fac/=2;
#endif
#endif


	  // Increment the forces.
	  for(int idx=0;idx<12;idx++) {
	    // Get the integral derivatives
	    erip=deri->getp(idx);

#ifdef DO_J
	    {
	      // E_J = P_ij (ij|kl) P_kl
	      double el=0.0;
	      /* Increment matrix */
	      for(size_t ii=0;ii<Ni;ii++) 
		for(size_t jj=0;jj<Nj;jj++)
		  for(size_t kk=0;kk<Nk;kk++)
		    for(size_t ll=0;ll<Nl;ll++)
		      el+=Pij(ii,jj)*Pkl(kk,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
	      
	      // Set the element
	      Jforce(idx)=Jfac*el;
	    }
#endif // DO_J
	    
	    
#ifdef DO_K
	    // E_K = P_ik (ij|kl) P_jl
	    {
	      double el=0.0;
	      /* Increment matrix */
	      for(size_t ii=0;ii<Ni;ii++) 
		for(size_t jj=0;jj<Nj;jj++)
		  for(size_t kk=0;kk<Nk;kk++)
		    for(size_t ll=0;ll<Nl;ll++)
		      el+=Pik(ii,kk)*Pjl(jj,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
	      
	      // Set the element
	      Kforce(idx)=K1fac*el;
	      

	      if(K2fac!=0.0) {
		el=0.0;
		/* Increment matrix */
		for(size_t ii=0;ii<Ni;ii++) 
		  for(size_t jj=0;jj<Nj;jj++)
		    for(size_t kk=0;kk<Nk;kk++)
		      for(size_t ll=0;ll<Nl;ll++)
			el+=Pjk(jj,kk)*Pil(ii,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
		
		// Increment the element
		Kforce(idx)+=K2fac*el;
	      }
	    }
#endif

#ifdef DO_Kab
	    // E_K = P_ik (ij|kl) P_jl
	    {
	      double ael=0.0, bel=0.0;
	      /* Increment matrix */
	      for(size_t ii=0;ii<Ni;ii++) 
		for(size_t jj=0;jj<Nj;jj++)
		  for(size_t kk=0;kk<Nk;kk++)
		    for(size_t ll=0;ll<Nl;ll++)
		      ael+=Paik(ii,kk)*Pajl(jj,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
	      for(size_t ii=0;ii<Ni;ii++) 
		for(size_t jj=0;jj<Nj;jj++)
		  for(size_t kk=0;kk<Nk;kk++)
		    for(size_t ll=0;ll<Nl;ll++)
		      bel+=Pbik(ii,kk)*Pbjl(jj,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
	      
	      // Set the element
	      Kaforce(idx)=K1fac*ael;
	      Kbforce(idx)=K1fac*bel;
	      
	      if(K2fac!=0.0) {
		ael=0.0;
		for(size_t ii=0;ii<Ni;ii++) 
		  for(size_t jj=0;jj<Nj;jj++)
		    for(size_t kk=0;kk<Nk;kk++)
		      for(size_t ll=0;ll<Nl;ll++)
			ael+=Pajk(jj,kk)*Pail(ii,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];

		bel=0.0;
		for(size_t ii=0;ii<Ni;ii++) 
		  for(size_t jj=0;jj<Nj;jj++)
		    for(size_t kk=0;kk<Nk;kk++)
		      for(size_t ll=0;ll<Nl;ll++)
			bel+=Pbjk(jj,kk)*Pbil(ii,ll)*(*erip)[((ii*Nj+jj)*Nk+kk)*Nl+ll];
		
		// Increment the element
		Kaforce(idx)+=K2fac*ael;
		Kbforce(idx)+=K2fac*bel;
	      }
	    }
#endif
	  } // End loop over idx
  
	  
	  // Increment forces on atoms
#ifdef DO_J
#ifdef _OPENMP
	  fJwrk.subvec(3*inuc,3*inuc+2)+=Jforce.subvec(0,2);
	  fJwrk.subvec(3*jnuc,3*jnuc+2)+=Jforce.subvec(3,5);
	  fJwrk.subvec(3*knuc,3*knuc+2)+=Jforce.subvec(6,8);
	  fJwrk.subvec(3*lnuc,3*lnuc+2)+=Jforce.subvec(9,11);
#else
	  fJ.subvec(3*inuc,3*inuc+2)+=Jforce.subvec(0,2);
	  fJ.subvec(3*jnuc,3*jnuc+2)+=Jforce.subvec(3,5);
	  fJ.subvec(3*knuc,3*knuc+2)+=Jforce.subvec(6,8);
	  fJ.subvec(3*lnuc,3*lnuc+2)+=Jforce.subvec(9,11);
#endif
#endif


#ifdef DO_K
#ifdef _OPENMP
	  fKwrk.subvec(3*inuc,3*inuc+2)+=Kforce.subvec(0,2);
	  fKwrk.subvec(3*jnuc,3*jnuc+2)+=Kforce.subvec(3,5);
	  fKwrk.subvec(3*knuc,3*knuc+2)+=Kforce.subvec(6,8);
	  fKwrk.subvec(3*lnuc,3*lnuc+2)+=Kforce.subvec(9,11);
#else
	  fK.subvec(3*inuc,3*inuc+2)+=Kforce.subvec(0,2);
	  fK.subvec(3*jnuc,3*jnuc+2)+=Kforce.subvec(3,5);
	  fK.subvec(3*knuc,3*knuc+2)+=Kforce.subvec(6,8);
	  fK.subvec(3*lnuc,3*lnuc+2)+=Kforce.subvec(9,11);
#endif
#endif

#ifdef DO_Kab
#ifdef _OPENMP
	  fKawrk.subvec(3*inuc,3*inuc+2)+=Kaforce.subvec(0,2);
	  fKawrk.subvec(3*jnuc,3*jnuc+2)+=Kaforce.subvec(3,5);
	  fKawrk.subvec(3*knuc,3*knuc+2)+=Kaforce.subvec(6,8);
	  fKawrk.subvec(3*lnuc,3*lnuc+2)+=Kaforce.subvec(9,11);

	  fKbwrk.subvec(3*inuc,3*inuc+2)+=Kbforce.subvec(0,2);
	  fKbwrk.subvec(3*jnuc,3*jnuc+2)+=Kbforce.subvec(3,5);
	  fKbwrk.subvec(3*knuc,3*knuc+2)+=Kbforce.subvec(6,8);
	  fKbwrk.subvec(3*lnuc,3*lnuc+2)+=Kbforce.subvec(9,11);
#else
	  fKa.subvec(3*inuc,3*inuc+2)+=Kaforce.subvec(0,2);
	  fKa.subvec(3*jnuc,3*jnuc+2)+=Kaforce.subvec(3,5);
	  fKa.subvec(3*knuc,3*knuc+2)+=Kaforce.subvec(6,8);
	  fKa.subvec(3*lnuc,3*lnuc+2)+=Kaforce.subvec(9,11);

	  fKb.subvec(3*inuc,3*inuc+2)+=Kbforce.subvec(0,2);
	  fKb.subvec(3*jnuc,3*jnuc+2)+=Kbforce.subvec(3,5);
	  fKb.subvec(3*knuc,3*knuc+2)+=Kbforce.subvec(6,8);
	  fKb.subvec(3*lnuc,3*lnuc+2)+=Kbforce.subvec(9,11);
#endif
#endif


#endif // FORCE
	
	
	} // End loop over jp pairs
      } // End loop over ip pairs

      // Collect results
#ifdef DO_J
#ifdef _OPENMP
#pragma omp critical
#endif
      {
#ifndef FORCE
	J+=Jwrk;
#else
	fJ+=fJwrk;
#endif
      }
#endif

#ifdef DO_K
#ifdef _OPENMP
#pragma omp critical
#endif
      {
#ifndef FORCE
	K+=Kwrk;
#else
	fK+=fKwrk;
#endif
      }
#endif

#ifdef DO_Kab
#ifdef _OPENMP
#pragma omp critical
#endif
      {
#ifndef FORCE
	Ka+=Kawrk;
	Kb+=Kbwrk;
#else
	fKa+=fKawrk;
	fKb+=fKbwrk;
#endif
      }
#endif
      
#ifndef FORCE
      delete eri;
#else
      delete deri;
#endif
    } // end parallel region

  double eff=calcd*100.0/(calcd+intskip);
  (void) eff;

#ifdef ERITABLE
  return shpairs.size();
#endif
  
#ifdef CALCJ
#ifndef FORCE
  return J;
#else
  return fJ;
#endif
#elif defined(CALCK)
#ifndef FORCE
  return K;
#else
  return fK;
#endif
#endif
}
