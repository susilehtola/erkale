/*
  Routines for computing ERIs. The same algorithm is used both for
  conventional and direct calculations.
*/

/* Function definitions */

#ifdef ERITABLE
void ERItable::fill(const BasisSet * basp) {
// Don't do anything with a dummy argument.
  if(basp==NULL)
    return;
#else

#if defined(CALCJKab)
void ERIscreen::calcJK(const arma::mat & Pa, const arma::mat & Pb, arma::mat & J, arma::mat & Ka, arma::mat & Kb, double tol, double *eff) const {
// Compute total density for Coulomb matrix
  arma::mat P=Pa+Pb;
#elif defined(CALCJK)
void ERIscreen::calcJK(const arma::mat & P, arma::mat & J, arma::mat & K, double tol, double *eff) const {
#elif defined(CALCK)
arma::mat ERIscreen::calcK(const arma::mat & P, double tol, double *eff) const {
  arma::mat K;
#else
arma::mat ERIscreen::calcJ(const arma::mat & P, double tol, double *eff) const {
  arma::mat J;
#endif // if defined(CALCJKab)

#endif // ifdef ERITABLE

  // Amount of basis functions
  size_t Nbf=basp->get_Nbf();

  /* Check sizes of input */

#if defined(CALCK) || defined(CALCJK)
  MAT_SIZE_CHECK(P,Nbf,Nbf,"P is not square!\n");
#endif

#if defined(CALCJKab)
  MAT_SIZE_CHECK(Pa,Nbf,Nbf,"Pa is not square!\n");
  MAT_SIZE_CHECK(Pb,Nbf,Nbf,"Pb is not square!\n");
#endif

  /* Check size of output */
#ifndef ERITABLE

#ifndef CALCK
  MAT_RESIZE(J,Nbf,Nbf);
  J.zeros();
#endif

#if defined(CALCK) || defined(CALCJK)
  MAT_RESIZE(K,Nbf,Nbf);
  K.zeros();
#endif

#if defined(CALCJKab)
  MAT_RESIZE(Ka,Nbf,Nbf);
  MAT_RESIZE(Kb,Nbf,Nbf);
  Ka.zeros();
  Kb.zeros(); 
#endif

#endif // ifndef ERITABLE

  /* Allocate memory for table of integrals */

#ifdef ERITABLE
  // Make index helper
  iidx=i_idx(Nbf*(Nbf+1)/2);
  // Make pairs helper
  for(size_t i=0;i<Nbf;i++)
    for(size_t j=0;j<=i;j++) {
      bfpair_t tmp;
      tmp.i=i;
      tmp.j=j;
      pairs.push_back(tmp);
    }
  
  // Compute memory requirements
  size_t N;
  N=N_ints(basp);

  // Don't do DOS
  if(N*sizeof(double)>2*1e9) {
    ERROR_INFO();
    throw std::out_of_range("Cowardly refusing to allocate more than two gigs of memory.\n");
  }

  try {
    ints.reserve(N);
    ints.resize(N);
  }
  catch(std::bad_alloc err) {
    std::ostringstream oss;

    ERROR_INFO();
    oss << "Was unable to reserve " << memory_size(N*sizeof(double)) << " of memory.\n";
    throw std::runtime_error(oss.str());
  }
#else
  // Number of calculated and skipped integrals
  size_t intskip=0, denskip=0, calcd=0;
#endif

  /* The filling algorithm may seem a bit complicated. This is because the ERIs
     are computed on a shell basis, and because the same algorithm is used here
     to form the ERIs as for direct calculations.

     In order to determine if the filling algorithm works perfectly, there is
     the CHECKFILL option to count the number each integral has been
     calculated.
  */

#ifdef CHECKFILL
  // Debug number of accesses
  printf("Allocating memory for checking table.\n");

#ifndef ERITABLE
  // Number of integrals is 
  size_t N=Nbf*(Nbf+1)*(Nbf*Nbf+Nbf+2)/8;
#endif
  std::vector<short int> nacc(N);
  for(size_t i=0;i<N;i++)
    nacc[i]=0;

#endif

  // Get list of unique shell pairs
  std::vector<shellpair_t> shpairs=basp->get_unique_shellpairs();
  // Get number of shell pairs
  const size_t Npairs=shpairs.size();

  // Maximum density matrix
#ifndef ERITABLE
  const size_t Nsh=basp->get_Nshells();
  arma::mat Psh(Nsh,Nsh);
  Psh.zeros();

  // Collect maximum density
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(size_t ip=0;ip<Npairs;ip++) {
    // Shells are
    size_t is=shpairs[ip].is;
    size_t js=shpairs[ip].js;
    // First functions on shells are
    size_t i0=basp->get_first_ind(is);
    size_t j0=basp->get_first_ind(js);
    // Indices of last functions on shells
    size_t ilast=basp->get_last_ind(is);
    size_t jlast=basp->get_last_ind(js);
    
    // Maximum value of density is
    Psh(is,js)=max_abs(P.submat(i0,j0,ilast,jlast));
    Psh(js,is)=Psh(is,js);
  }
#endif


  // Loop over first pairs
#ifdef _OPENMP

#ifdef ERITABLE
#pragma omp parallel
#else
#pragma omp parallel reduction(+:calcd,intskip,denskip)
#endif

#endif // ifdef _OPENMP
  {

#ifndef ERITABLE
    // Arrays of identical integrals
    size_t iarr[8], jarr[8], karr[8], larr[8];
    size_t nid; // Number of identical integrals in this batch

#ifdef _OPENMP
    const arma::mat Pwrk=P;
    const arma::mat Pshwrk=Psh;
#ifdef CALCJKab
    const arma::mat Pawrk=Pa;
    const arma::mat Pbwrk=Pb;
#endif
#endif

#ifdef _OPENMP    
#ifndef CALCK
    arma::mat Jwrk(Nbf,Nbf);
    Jwrk.zeros();
#endif

#if defined(CALCK) || defined(CALCJK)
    arma::mat Kwrk(Nbf,Nbf);
    Kwrk.zeros();
#endif

#ifdef CALCJKab
    arma::mat Kawrk(Nbf,Nbf);
    Kawrk.zeros();

    arma::mat Kbwrk(Nbf,Nbf);
    Kbwrk.zeros();
#endif
#endif

#endif // ifndef ERITABLE


#ifdef _OPENMP
#pragma omp for schedule(dynamic)
#endif // ifdef _OPENMP
    for(size_t ip=0;ip<Npairs;ip++) {
      // Loop over second pairs
      for(size_t jp=0;jp<=ip;jp++) {


	// Shells on first pair are
	size_t ks=shpairs[ip].is;
	size_t ls=shpairs[ip].js;
	// First functions on shells are
	size_t k0=basp->get_first_ind(ks);
	size_t l0=basp->get_first_ind(ls);
	// and amounts of functions on shells are
	size_t Nk=basp->get_Nbf(ks);
	size_t Nl=basp->get_Nbf(ls);
	
	// Shells on second pair are
	size_t is=shpairs[jp].is;
	size_t js=shpairs[jp].js;
	// First functions on shells are
	size_t i0=basp->get_first_ind(is);
	size_t j0=basp->get_first_ind(js);
	// and amounts of functions on shells are
	size_t Ni=basp->get_Nbf(is);
	size_t Nj=basp->get_Nbf(js);
	
	/* Perform screening of integrals */
#ifndef ERITABLE
	// Maximum value of the 2-electron integrals on this shell pair
	double intmax=screen(is,js)*screen(ks,ls);
	
	if(intmax<tol) {
	  // Skip integral due to small value of integral
	  intskip++;
	  continue;
	  
	} else {
	  // Compute maximum density
	  arma::vec Pv(6);
	  Pv.zeros();
#ifdef _OPENMP
	  Pv(0)=Pshwrk(is,js);
	  Pv(1)=Pshwrk(is,ks);
	  Pv(2)=Pshwrk(is,ls);
	  Pv(3)=Pshwrk(js,ks);
	  Pv(4)=Pshwrk(js,ls);
	  Pv(5)=Pshwrk(ks,ls);
#else
	  Pv(0)=Psh(is,js);
	  Pv(1)=Psh(is,ks);
	  Pv(2)=Psh(is,ls);
	  Pv(3)=Psh(js,ks);
	  Pv(4)=Psh(js,ls);
	  Pv(5)=Psh(ks,ls);
#endif
	  double maxP=max(Pv);
	  
	  if(maxP*intmax<tol) {
	    // Skip integral due to small product of density and integral
	    denskip++;
	    continue;
	  } else
	    // Need to calculate integral.
	    calcd++;
	}
#endif
	
	// Compute integrals
	std::vector<double> tmp=basp->ERI(is,js,ks,ls);
#ifdef _OPENMP
	//	printf("Thread %i computed (%i %i %i %i)\n",omp_get_thread_num(),is,js,ks,ls);
#endif
	
	
	/*
	  printf("\nShells (%i %i | %i %i)\n",is,js,ks,ls);
	  printf("Integrals are:");
	  for(size_t in=0;in<tmp.size();in++)
	  printf(" % e",tmp[in]);
	  printf("\n");
	*/

	/* Fill table, or increment matrices */
	{
	  // Helpers
	  size_t i, j, k, l;
	  size_t iimax, jjmax, kkmax, llmax;
	  
	  if(is==js && ks==ls && is==ks) {
	    // All shells are the same: (is is | is is)
	    
	    iimax=Ni-1;
	    for(size_t ii=0;ii<=iimax;ii++) {
	      i=i0+ii;
	      
	      jjmax=ii;
	      for(size_t jj=0;jj<=jjmax;jj++) {
		j=j0+jj;
		
		kkmax=ii;
		for(size_t kk=0;kk<=kkmax;kk++) {
		  k=k0+kk;
		  
		  // jj if kk and ii are same, otherwise kk
		  llmax = (kk==ii) ? jj : kk ; 
		  for(size_t ll=0;ll<=llmax;ll++) {
		    l=l0+ll;
		    
		    // Store integral or increment matrices
#include "eri-routines-increment.cpp.in"
		    
		  }
		}
	      }
	    }
	  } else if(is==ks && js==ls) {
	    // Two shells are the same: (is js | is js)
	    
	    iimax=Ni-1;
	    jjmax=Nj-1;
	    
	    for(size_t ii=0;ii<=iimax;ii++) {
	      i=i0+ii;
	      for(size_t jj=0;jj<=jjmax;jj++) {
		j=j0+jj;
		
		kkmax=ii;
		for(size_t kk=0;kk<=kkmax;kk++) {
		  k=k0+kk;
		  
		  llmax = (kk==ii) ? jj : Nl-1 ;
		  for(size_t ll=0;ll<=llmax;ll++) {
		    l=l0+ll;
		    
		    // Store integral or increment matrices
#include "eri-routines-increment.cpp.in"
		    
		  }
		}
	      }
	    }
	  } else {
	    // (is js | ks ls) case
	    
	    iimax=Ni-1;
	    kkmax=Nk-1;
	    for(size_t ii=0;ii<=iimax;ii++) {
	      i=i0+ii;
	      
	      jjmax= (is==js) ? ii : Nj-1;
	      for(size_t jj=0;jj<=jjmax;jj++) {
		j=j0+jj;
		
		for(size_t kk=0;kk<=kkmax;kk++) {
		  k=k0+kk;
		  
		  llmax = (ks==ls) ? kk : Nl-1 ;
		  for(size_t ll=0;ll<=llmax;ll++) {
		    l=l0+ll;
		    
		    // Store integral or increment matrices
#include "eri-routines-increment.cpp.in"
		    
		  }
		}
	      }
	    }
	  }
	} // end critical region
      }
    }
    
    // Collect results
#if !defined(ERITABLE) && defined(_OPENMP)

#ifndef CALCK
#pragma omp critical
    J+=Jwrk;
#endif

#if defined(CALCK) || defined(CALCJK)
#pragma omp critical
    K+=Kwrk;
#endif

#ifdef CALCJKab
#pragma omp critical
    Ka+=Kawrk;
    Kb+=Kbwrk;
#endif

#endif

  } // end parallel region
  
#ifdef CHECKFILL  
  size_t ndupl=0, nmiss=0;
  bool print;
  for(size_t i=0;i<N;i++) {
    print=0;
    if(nacc[i]==0) {
      printf("Integral %i has not been calculated.\n",(int) i);
      nmiss++;
      print=1;
    } else if(nacc[i]>1) {
      printf("Integral %i has been calculated %i times.\n",(int) i,nacc[i]);
      ndupl++;
      print=1;
    }
    if(print) {
      // Find out index
      bool found=0;
      for(size_t ii=0;ii<Nbf;ii++) {
	for(size_t jj=0;jj<Nbf;jj++) {
	  for(size_t kk=0;kk<Nbf;kk++) {
	    for(size_t ll=0;ll<Nbf;ll++) {
	      
	      if(i==idx(ii,jj,kk,ll)) {
		printf("It is %i %i %i %i.\n",ii,jj,kk,ll);
		found=1;
		break;
	      }
	    }
	    
	    if(found)
	      break;
	  }
	  if(found)
	    break;
	}
	if(found)
	  break;
      }
      
    }
  }
  
  printf("%lu are missing and %lu are duplicates.\n", nmiss, ndupl);
#endif

#ifndef ERITABLE
  // Compute screening efficiency
  //  printf("Computed %lu shells, skipped %lu due to small absolute value and %lu due to small product.\n",calcd,intskip,denskip);

  if(eff!=NULL) {
    *eff=calcd*100.0/(calcd+intskip+denskip);
  }
#endif

#ifdef CALCJ
  return J;
#elif defined(CALCK)
  return K;
#endif
}
