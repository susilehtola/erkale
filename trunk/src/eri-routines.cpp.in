/*
  Routines for computing ERIs. The same algorithm is used both for
  conventional and direct calculations.
*/

/* Function definitions */

#if defined(ERITABLE)
void ERItable::fill(const BasisSet * basp, double tol) {
#endif

#if defined(CALCJKab)
void ERIscreen::calcJK(const arma::mat & Pa, const arma::mat & Pb, arma::mat & J, arma::mat & Ka, arma::mat & Kb, double tol, double *eff) const {
  // Compute total density for Coulomb matrix
  arma::mat P=Pa+Pb;
#endif


#if defined(CALCJK)
void ERIscreen::calcJK(const arma::mat & P, arma::mat & J, arma::mat & K, double tol, double *eff) const {
#endif

#if defined(CALCK)
arma::mat ERIscreen::calcK(const arma::mat & P, double tol, double *eff) const {
  arma::mat K;
#endif

#if defined(CALCJ)
arma::mat ERIscreen::calcJ(const arma::mat & P, double tol, double *eff) const {
  arma::mat J;
#endif

  // Amount of basis functions
  size_t Nbf=basp->get_Nbf();
  // Shells
  std::vector<GaussianShell> shells=basp->get_shells();

  /* Check sizes of input */

#if defined(CALCJ) || defined(CALCJK) || defined(CALCJKab)
#define DO_J
  J.zeros(Nbf,Nbf);
#endif

#if defined(CALCK) || defined(CALCJK)
#define DO_K
  K.zeros(Nbf,Nbf);
#endif

#if defined(CALCJKab)
#define DO_Kab
#endif

#if defined(DO_J) || defined(DO_K)
  MAT_SIZE_CHECK(P,Nbf,Nbf,"P is not square!\n");
#endif

#if defined(DO_Kab)
  MAT_SIZE_CHECK(Pa,Nbf,Nbf,"Pa is not square!\n");
  MAT_SIZE_CHECK(Pb,Nbf,Nbf,"Pb is not square!\n");

  Ka.zeros(Nbf,Nbf);
  Kb.zeros(Nbf,Nbf);
#endif

  /* Allocate memory for table of integrals */
#ifdef ERITABLE
  // Make index helper
  iidx=i_idx(Nbf*(Nbf+1)/2);
  // Make pairs helper
  for(size_t i=0;i<Nbf;i++)
    for(size_t j=0;j<=i;j++) {
      bfpair_t tmp;
      tmp.i=i;
      tmp.j=j;
      pairs.push_back(tmp);
    }

  // Compute memory requirements
  size_t N;
  N=N_ints(basp);

  // Don't do DOS
  if(N*sizeof(double)>14*1e9) {
    ERROR_INFO();
    throw std::out_of_range("Cowardly refusing to allocate more than 14 gigs of memory.\n");
  }

  try {
    ints.reserve(N);
    ints.resize(N);
  } catch(std::bad_alloc err) {
    std::ostringstream oss;

    ERROR_INFO();
    oss << "Was unable to reserve " << memory_size(N*sizeof(double)) << " of memory.\n";
    throw std::runtime_error(oss.str());
  }

  // Initialize with zeros
  for(size_t i=0;i<N;i++)
    ints[i]=0.0;
#endif

  // Number of calculated and skipped integrals
  size_t intskip=0, calcd=0;
#ifndef ERITABLE
  size_t denskip=0;
#endif

  /* The filling algorithm may seem a bit complicated. This is because the ERIs
     are computed on a shell basis, and because the same algorithm is used here
     to form the ERIs as for direct calculations.
  */

  // Get list of unique shell pairs
  std::vector<shellpair_t> shpairs=basp->get_unique_shellpairs();
  // Get number of shell pairs
  const size_t Npairs=shpairs.size();

#if !defined(ERITABLE)
  const size_t Nsh=basp->get_Nshells();
  arma::mat Psh(Nsh,Nsh);
  Psh.zeros();

  // Collect maximum density
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(size_t ip=0;ip<Npairs;ip++) {
    // Shells are
    size_t is=shpairs[ip].is;
    size_t js=shpairs[ip].js;
    // First functions on shells are
    size_t i0=basp->get_first_ind(is);
    size_t j0=basp->get_first_ind(js);
    // Indices of last functions on shells
    size_t ilast=basp->get_last_ind(is);
    size_t jlast=basp->get_last_ind(js);

    // Maximum value of density is
    Psh(is,js)=max_abs(P.submat(i0,j0,ilast,jlast));
    Psh(js,is)=Psh(is,js);
  }
#endif


#if defined(ERITABLE)
  // Form screening matrix
  const size_t Nsh=basp->get_Nshells();
  arma::mat screen(Nsh,Nsh);

#ifdef _OPENMP
#pragma omp parallel
#endif
  {
    ERIWorker eri(basp->get_max_am(),basp->get_max_Ncontr());
    std::vector<double> tmp;

#ifdef _OPENMP
#pragma omp for schedule(dynamic)
#endif
    for(size_t ip=0;ip<Npairs;ip++) {
      size_t i=shpairs[ip].is;
      size_t j=shpairs[ip].js;

      // Compute integrals
      eri.compute(&shells[i],&shells[j],&shells[i],&shells[j],tmp);
      // Get maximum value
      double m=0.0;
      for(size_t k=0;k<tmp.size();k++)
	if(fabs(tmp[k])>m)
	  m=fabs(tmp[k]);
      m=sqrt(m);
      screen(i,j)=m;
      screen(j,i)=m;
    }
  }
#endif

  // Loop over first pairs
#ifdef _OPENMP

#ifdef ERITABLE
#pragma omp parallel
#else
#pragma omp parallel reduction(+:calcd,intskip,denskip)
#endif
#endif // ifdef _OPENMP
  { // Open parallel region

    /// ERI worker
    ERIWorker eri(basp->get_max_am(),basp->get_max_Ncontr());

    /// Integral array
    std::vector<double> eris;

#ifdef DO_J
    arma::mat Jwrk(J);
#endif

#ifdef DO_K
    arma::mat Kwrk(K);
#endif

#ifdef DO_Kab
    arma::mat Kawrk(Ka);
    arma::mat Kbwrk(Kb);
#endif

#ifdef _OPENMP
#pragma omp for schedule(dynamic)
#endif
    for(size_t ip=0;ip<Npairs;ip++) {
      // Loop over second pairs
      for(size_t jp=0;jp<=ip;jp++) {

	// Shells on second pair are
	size_t ks=shpairs[ip].is;
	size_t ls=shpairs[ip].js;
	// and those on the first pair
	size_t is=shpairs[jp].is;
	size_t js=shpairs[jp].js;

	// First functions on shells are
	size_t k0=basp->get_first_ind(ks);
	size_t l0=basp->get_first_ind(ls);
	// and on the first pair
	size_t i0=basp->get_first_ind(is);
	size_t j0=basp->get_first_ind(js);

	// Amount of functions on the second pair
	size_t Nk=basp->get_Nbf(ks);
	size_t Nl=basp->get_Nbf(ls);
	// and on the first pair
	size_t Ni=basp->get_Nbf(is);
	size_t Nj=basp->get_Nbf(js);

	// Maximum value of the 2-electron integrals on this shell pair
	double intmax=screen(is,js)*screen(ks,ls);
	if(intmax<tol) {
	  // Skip integral due to small value of integral
	  intskip++;
	  continue;
	}

#if !defined(ERITABLE)
	// Do density screening?

	// Coulomb
	bool coulskip=true;
#ifdef DO_J
	if(intmax*std::max(Psh(is,js),Psh(ks,ls))>=tol)
	  coulskip=false;
#endif

	// Exchange
	bool exchskip=true;
#if defined(DO_K) || defined(DO_Kab)
	double denmax=std::max(std::max(Psh(ks,ls),Psh(is,ls)),std::max(Psh(ks,js),Psh(is,js)));
	if(intmax*denmax>=tol)
	  exchskip=false;
#endif

	if(coulskip && exchskip) {
	  denskip++;
	  continue;
	}
#endif // if !defined(ERITABLE)

	// Increment amount of calculated integrals
	calcd++;

	// Compute integrals
	eri.compute(&shells[is],&shells[js],&shells[ks],&shells[ls],eris);

#ifdef ERITABLE
	// Store integrals
	for(size_t ii=0;ii<Ni;ii++)
	  for(size_t jj=0;jj<Nj;jj++)
	    for(size_t kk=0;kk<Nk;kk++)
	      for(size_t ll=0;ll<Nl;ll++)
		ints[idx(i0+ii,j0+jj,k0+kk,l0+ll)]=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll];
#endif

	// Increment matrices.
#ifdef DO_J

	// J_ij = (ij|kl) P_kl
	{
	  // Work matrix
	  arma::mat Jij(Ni,Nj);
	  Jij.zeros();
	  arma::mat Pkl=P.submat(k0,l0,k0+Nk-1,l0+Nl-1);

	  // Degeneracy factor
	  double fac=1.0;
	  if(ks!=ls)
	    fac=2.0;

	  /* Increment matrix */
	  for(size_t ii=0;ii<Ni;ii++) 
	    for(size_t jj=0;jj<Nj;jj++) {

	      // Matrix element
	      double el=0.0;
	      for(size_t kk=0;kk<Nk;kk++)
		for(size_t ll=0;ll<Nl;ll++)
		  el+=Pkl(kk,ll)*eris[((ii*Nj+jj)*Nk+kk)*Nl+ll];

	      // Set the element
	      Jij(ii,jj)+=fac*el;
	    }

	  // Store the matrix element
	  Jwrk.submat(i0,j0,i0+Ni-1,j0+Nj-1)+=Jij;
	  if(is!=js)
	    Jwrk.submat(j0,i0,j0+Nj-1,i0+Ni-1)+=arma::trans(Jij);
	}

	// Permutation:
	// J_kl = (ij|kl) P_ij
	if(ip!=jp) {
	  // Work matrix
	  arma::mat Jkl(Nk,Nl);
	  Jkl.zeros();
	  arma::mat Pij=P.submat(i0,j0,i0+Ni-1,j0+Nj-1);

	  // Degeneracy factor
	  double fac=1.0;
	  if(is!=js)
	    fac=2.0;

	  /* Increment matrix */
	  for(size_t kk=0;kk<Nk;kk++)
	    for(size_t ll=0;ll<Nl;ll++) {

	      // Matrix element
	      double el=0.0;
	      for(size_t ii=0;ii<Ni;ii++) {
		for(size_t jj=0;jj<Nj;jj++) {
		  el+=Pij(ii,jj)*eris[((ii*Nj+jj)*Nk+kk)*Nl+ll];
		}
	      }
	      
	      // Set the element
	      Jkl(kk,ll)+=fac*el;
	    }

	  // Store the matrix element
	  Jwrk.submat(k0,l0,k0+Nk-1,l0+Nl-1)+=Jkl;
	  if(ks!=ls)
	    Jwrk.submat(l0,k0,l0+Nl-1,k0+Nk-1)+=arma::trans(Jkl);
	}
#endif

#if defined(DO_K) || defined(DO_Kab)
	{
	  /* When all indices are different, the following integrals are
	     equivalent:

	     (ij|kl) (ij|lk) (ji|kl) (ji|lk)
	     (kl|ij) (kl|ji) (lk|ij) (lk|ji)

	     This translates to

	     K(i,k) += (ij|kl) P(j,l) // always
	     K(j,k) += (ij|kl) P(i,l) // if (is!=js)
	     K(i,l) += (ij|kl) P(j,k) // if (ls!=ks)
	     K(j,l) += (ij|kl) P(i,k) // if (is!=js) and (ls!=ks)

	     and for ij != kl

	     K(k,i) += (ij|kl) P(j,l) // always
	     K(k,j) += (ij|kl) P(i,l) // if (is!=js)
	     K(l,i) += (ij|kl) P(j,k) // if (ks!=ls)
	     K(l,j) += (ij|kl) P(i,k) // if (is!=js) and (ks!=ls)

	     However, the latter four permutations just make the
	     exchange matrix symmetric. So the only thing we need to do
	     is do the first four permutations, and at the end we sum up
	     K_ij and K_ji for j>i and set K_ij and K_ji to this
	     value. This makes things a *lot* easier. So:

	     We just need to check if the shells are different, in which
	     case K will get extra incremenets.
	  */

	  // First, do the ij part:  K(i,l) += (ij|kl) P(j,k)
	  {
#ifdef DO_K
	    arma::mat Kik(Ni,Nk);
	    Kik.zeros();
	    arma::mat Pjl=P.submat(j0,l0,j0+Nj-1,l0+Nl-1);
#else
	    arma::mat Kaik(Ni,Nk);
	    Kaik.zeros();
	    arma::mat Pajl=Pa.submat(j0,l0,j0+Nj-1,l0+Nl-1);

	    arma::mat Kbik(Ni,Nk);
	    Kbik.zeros();
	    arma::mat Pbjl=Pb.submat(j0,l0,j0+Nj-1,l0+Nl-1);
#endif

	    // Increment Kik
	    for(size_t ii=0;ii<Ni;ii++)
	      for(size_t kk=0;kk<Nk;kk++)
		for(size_t ll=0;ll<Nl;ll++)
		  for(size_t jj=0;jj<Nj;jj++)
		    {
#ifdef DO_K
		      Kik(ii,kk)+=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pjl(jj,ll);
#else
		      Kaik(ii,kk)+=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pajl(jj,ll);
		      Kbik(ii,kk)+=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pbjl(jj,ll);
#endif
		    }

	    // Set elements
	    for(size_t ii=0;ii<Ni;ii++)
	      for(size_t kk=0;kk<Nk;kk++) {
		size_t i=i0+ii;
		size_t k=k0+kk;
#ifdef DO_K
		Kwrk(i,k)+=Kik(ii,kk);
#else
		Kawrk(i,k)+=Kaik(ii,kk);
		Kbwrk(i,k)+=Kbik(ii,kk);
#endif
	      }

	    // Symmetrize if necessary
	    if(ip!=jp)
	      for(size_t kk=0;kk<Nk;kk++)
		for(size_t ii=0;ii<Ni;ii++) {
		  size_t i=i0+ii;
		  size_t k=k0+kk;
#ifdef DO_K
		  Kwrk(k,i)+=Kik(ii,kk);
#else
		  Kawrk(k,i)+=Kaik(ii,kk);
		  Kbwrk(k,i)+=Kbik(ii,kk);
#endif
		}
	  }


	  // Then, the second part
	  // K(j,k) += (ij|kl) P(i,l)
	  if(is!=js) {
#ifdef DO_K
	    arma::mat Kjk(Nj,Nk);
	    Kjk.zeros();
	    arma::mat Pil=P.submat(i0,l0,i0+Ni-1,l0+Nl-1);
#else
	    arma::mat Kajk(Nj,Nk);
	    arma::mat Kbjk(Nj,Nk);
	    Kajk.zeros();
	    Kbjk.zeros();
	    arma::mat Pail=Pa.submat(i0,l0,i0+Ni-1,l0+Nl-1);
	    arma::mat Pbil=Pb.submat(i0,l0,i0+Ni-1,l0+Nl-1);
#endif

	    // Increment Kjk
	    for(size_t jj=0;jj<Nj;jj++)
	      for(size_t kk=0;kk<Nk;kk++)
		for(size_t ll=0;ll<Nl;ll++)
		  for(size_t ii=0;ii<Ni;ii++) {
#ifdef DO_K
		    Kjk(jj,kk)+=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pil(ii,ll);
#else
		    Kajk(jj,kk)+=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pail(ii,ll);
		    Kbjk(jj,kk)+=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pbil(ii,ll);
#endif
		  }

	    // Set elements
	    for(size_t jj=0;jj<Nj;jj++)
	      for(size_t kk=0;kk<Nk;kk++) {
		size_t j=j0+jj;
		size_t k=k0+kk;
#ifdef DO_K
		Kwrk(j,k)+=Kjk(jj,kk);
#else
		Kawrk(j,k)+=Kajk(jj,kk);
		Kbwrk(j,k)+=Kbjk(jj,kk);
#endif
	      }

	    // Symmetrize if necessary (take care about possible overlap with next routine)
	    if((js!=ks || is!=ls) && ip!=jp) {
	      for(size_t kk=0;kk<Nk;kk++)
		for(size_t jj=0;jj<Nj;jj++) {
		  size_t j=j0+jj;
		  size_t k=k0+kk;
#ifdef DO_K
		  Kwrk(k,j)+=Kjk(jj,kk);
#else
		  Kawrk(k,j)+=Kajk(jj,kk);
		  Kbwrk(k,j)+=Kbjk(jj,kk);
#endif
		}
	    }
	  }


	  // Third part
	  //  K(i,l) += (ij|kl) P(j,k)
	  if(ks!=ls) {
#ifdef DO_K
	    arma::mat Kil(Ni,Nl);
	    Kil.zeros();
	    arma::mat Pjk=P.submat(j0,k0,j0+Nj-1,k0+Nk-1);
#else
	    arma::mat Kail(Ni,Nl);
	    arma::mat Kbil(Ni,Nl);
	    Kail.zeros();
	    Kbil.zeros();
	    arma::mat Pajk=Pa.submat(j0,k0,j0+Nj-1,k0+Nk-1);
	    arma::mat Pbjk=Pb.submat(j0,k0,j0+Nj-1,k0+Nk-1);
#endif

	    // Increment Kil
	    for(size_t ii=0;ii<Ni;ii++)
	      for(size_t ll=0;ll<Nl;ll++)
		for(size_t jj=0;jj<Nj;jj++)
		  for(size_t kk=0;kk<Nk;kk++) {
#ifdef DO_K
		    Kil(ii,ll)+=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pjk(jj,kk);
#else
		    Kail(ii,ll)+=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pajk(jj,kk);
		    Kbil(ii,ll)+=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pbjk(jj,kk);
#endif
		  }

	    // Set elements
	    for(size_t ii=0;ii<Ni;ii++)
	      for(size_t ll=0;ll<Nl;ll++) {
		size_t i=i0+ii;
		size_t l=l0+ll;
#ifdef DO_K
		Kwrk(i,l)+=Kil(ii,ll);
#else
		Kawrk(i,l)+=Kail(ii,ll);
		Kbwrk(i,l)+=Kbil(ii,ll);
#endif
	      }

	    // Symmetrize if necessary
	    if((js!=ks || is!=ls) && ip!=jp)
	      for(size_t ll=0;ll<Nl;ll++)
		for(size_t ii=0;ii<Ni;ii++) {
		  size_t i=i0+ii;
		  size_t l=l0+ll;
#ifdef DO_K
		  Kwrk(l,i)+=Kil(ii,ll);
#else
		  Kawrk(l,i)+=Kail(ii,ll);
		  Kbwrk(l,i)+=Kbil(ii,ll);
#endif
		}
	  }


	  // Last permutation
	  // K(j,l) += (ij|kl) P(i,k)
	  if(is!=js && ks!=ls) {
#ifdef DO_K
	    arma::mat Kjl(Nj,Nl);
	    Kjl.zeros();
	    arma::mat Pik=P.submat(i0,k0,i0+Ni-1,k0+Nk-1);
#else
	    arma::mat Kajl(Nj,Nl);
	    arma::mat Kbjl(Nj,Nl);
	    Kajl.zeros();
	    Kbjl.zeros();
	    arma::mat Paik=Pa.submat(i0,k0,i0+Ni-1,k0+Nk-1);
	    arma::mat Pbik=Pb.submat(i0,k0,i0+Ni-1,k0+Nk-1);
#endif

	    // Increment Kjl
	    for(size_t jj=0;jj<Nj;jj++)
	      for(size_t ll=0;ll<Nl;ll++)
		for(size_t ii=0;ii<Ni;ii++)
		  for(size_t kk=0;kk<Nk;kk++) {
#ifdef DO_K
		    Kjl(jj,ll)+=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pik(ii,kk);
#else
		    Kajl(jj,ll)+=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Paik(ii,kk);
		    Kbjl(jj,ll)+=eris[((ii*Nj+jj)*Nk+kk)*Nl+ll]*Pbik(ii,kk);
#endif
		  }

	    // Set elements
	    for(size_t jj=0;jj<Nj;jj++)
	      for(size_t ll=0;ll<Nl;ll++) {
		size_t j=j0+jj;
		size_t l=l0+ll;
#ifdef DO_K
		Kwrk(j,l)+=Kjl(jj,ll);
#else
		Kawrk(j,l)+=Kajl(jj,ll);
		Kbwrk(j,l)+=Kbjl(jj,ll);
#endif
	      }

	    // Symmetrize if necessary
	    if ((js!=ks || is!=ls) && ip!=jp)
	      for(size_t ll=0;ll<Nl;ll++)
		for(size_t jj=0;jj<Nj;jj++) {
		  size_t j=j0+jj;
		  size_t l=l0+ll;
#ifdef DO_K
		  Kwrk(l,j)+=Kjl(jj,ll);
#else
		  Kawrk(l,j)+=Kajl(jj,ll);
		  Kbwrk(l,j)+=Kbjl(jj,ll);
#endif
		}
	  }
	}
#endif // ifdef DO_K || DO_Kab


      } // End loop over jp pairs
    } // End loop over ip pairs

    // Collect results
#ifdef DO_J
#ifdef _OPENMP
#pragma omp critical
#endif
    {
      J+=Jwrk;
    }
#endif

#ifdef DO_K
#ifdef _OPENMP
#pragma omp critical
#endif
    {
      K+=Kwrk;
    }
#endif

#ifdef DO_Kab
#ifdef _OPENMP
#pragma omp critical
#endif
    {
      Ka+=Kawrk;
      Kb+=Kbwrk;
    }
#endif

  } // end parallel region

#ifndef ERITABLE
  // Compute screening efficiency
  //  printf("Computed %lu shells, skipped %lu due to small absolute value and %lu due to small product.\n",calcd,intskip,denskip);

  if(eff!=NULL) {
    *eff=calcd*100.0/(calcd+intskip+denskip);
  }
#endif

#ifdef CALCJ
  return J;
#elif defined(CALCK)
  return K;
#endif
}
