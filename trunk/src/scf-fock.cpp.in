/*
 *                This source code is part of
 *
 *                     E  R  K  A  L  E
 *                             -
 *                       DFT from Hel
 *
 * Written by Susi Lehtola, 2010-2013
 * Copyright (c) 2010-2013, Susi Lehtola
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 */

#include "global.h"

/* Restricted case */
#if defined(RESTRICTED) && defined(DFT)
void SCF::Fock_RDFT(rscf_t & sol, const std::vector<double> & occs, const dft_t dft, const rscf_t & oldsol, DFTGrid & grid, DFTGrid & nlgrid, double tol) const

#elif defined(RESTRICTED) && defined(HF)
void SCF::Fock_RHF(rscf_t & sol, const std::vector<double> & occs, const rscf_t & oldsol, double tol) const

#elif defined(UNRESTRICTED) && defined(DFT)
void SCF::Fock_UDFT(uscf_t & sol, const std::vector<double> & occa, const std::vector<double> & occb, const dft_t dft, const uscf_t & oldsol, DFTGrid & grid, DFTGrid & nlgrid, double tol) const

#elif defined(UNRESTRICTED) && defined(HF)
void SCF::Fock_UHF(uscf_t & sol, const std::vector<double> & occa, const std::vector<double> & occb, const uscf_t & oldsol, double tol) const

#elif defined(UNRESTRICTED) && defined(_ROHF)
void SCF::Fock_ROHF(uscf_t & sol, const std::vector<double> & occa, const std::vector<double> & occb, const uscf_t & oldsol, double tol) const

#elif defined(DFT) && defined(FULLHOLE)
void XRSSCF::Fock_full_hole(uscf_t & sol, dft_t dft, const std::vector<double> & occa, const std::vector<double> & occb, const uscf_t & oldsol, DFTGrid & grid, DFTGrid & nlgrid, double tol) const

#elif defined(DFT) && defined(HALFHOLE)
void XRSSCF::Fock_half_hole(uscf_t & sol, dft_t dft, const std::vector<double> & occa, const std::vector<double> & occb, const uscf_t & oldsol, DFTGrid & grid, DFTGrid & nlgrid, double tol) const
#endif
{
  Timer t;

  // Consistency check
  MAT_SIZE_CHECK(sol.P,Nbf,Nbf);
#ifndef RESTRICTED
  MAT_SIZE_CHECK(sol.Pa,Nbf,Nbf);
  MAT_SIZE_CHECK(sol.Pb,Nbf,Nbf);
#endif

  // Coulomb and exchange matrices
  sol.J.zeros(Nbf,Nbf);
#ifdef RESTRICTED
  sol.K.zeros(Nbf,Nbf);
#else
  sol.Ka.zeros(Nbf,Nbf);
  sol.Kb.zeros(Nbf,Nbf);
#endif

#if defined(DFT) && defined(RESTRICTED)
  // Exchange-correlation functional
  sol.XC.zeros(Nbf,Nbf);
#endif
#if defined(DFT) && !defined(RESTRICTED)
  // Exchange-correlation functional
  sol.XCa.zeros(Nbf,Nbf);
  sol.XCb.zeros(Nbf,Nbf);
#endif

#ifdef DFT
  // Range separation constants
  double omega, kfull, kshort;
  range_separation(dft.x_func,omega,kfull,kshort);
#endif

  // Range-separated exchange matrices
#ifdef RESTRICTED
  arma::mat Kfull, Kfull_im, Kshort, Kshort_im;
  Kfull.zeros(Nbf,Nbf);
  Kfull_im.zeros(Nbf,Nbf);
  Kshort.zeros(Nbf,Nbf);
  Kshort_im.zeros(Nbf,Nbf);
#else
  arma::mat Kafull, Kafull_im, Kbfull, Kbfull_im, Kashort, Kashort_im, Kbshort, Kbshort_im;
  Kafull.zeros(Nbf,Nbf);
  Kafull_im.zeros(Nbf,Nbf);
  Kbfull.zeros(Nbf,Nbf);
  Kbfull_im.zeros(Nbf,Nbf);
  Kashort.zeros(Nbf,Nbf);
  Kashort_im.zeros(Nbf,Nbf);
  Kbshort.zeros(Nbf,Nbf);
  Kbshort_im.zeros(Nbf,Nbf);
#endif

  // Form change-of-density matrices
#ifdef RESTRICTED
  arma::mat deltaP(Nbf,Nbf);
  if(oldsol.P.n_rows == Nbf && oldsol.P.n_cols == Nbf && oldsol.J.n_rows==Nbf && oldsol.J.n_cols==Nbf && oldsol.K.n_rows == Nbf && oldsol.K.n_cols == Nbf) {
    sol.J=oldsol.J;
    sol.K=oldsol.K;
    deltaP=sol.P-oldsol.P;
  } else {
    sol.J.zeros();
    sol.K.zeros();
    deltaP=sol.P;
  }
#else
  arma::mat deltaPa(Nbf,Nbf), deltaPb(Nbf,Nbf);
  if(oldsol.Pa.n_rows==Nbf && oldsol.Pa.n_cols==Nbf && oldsol.Pb.n_rows==Nbf && oldsol.Pb.n_cols==Nbf && oldsol.J.n_rows == Nbf && oldsol.J.n_cols == Nbf && oldsol.Ka.n_rows == Nbf && oldsol.Ka.n_cols == Nbf && oldsol.Kb.n_rows == Nbf && oldsol.Kb.n_cols == Nbf) {
    sol.J=oldsol.J;
    sol.Ka=oldsol.Ka;
    sol.Kb=oldsol.Kb;
    deltaPa=sol.Pa-oldsol.Pa;
    deltaPb=sol.Pb-oldsol.Pb;
  } else {
    sol.Ka.zeros();
    sol.Kb.zeros();
    sol.J.zeros();
    deltaPa=sol.Pa;
    deltaPb=sol.Pb;
  }
  arma::mat deltaP=deltaPa+deltaPb;
#endif

  double screeneff;

  // Form Coulomb and exchange matrices
  if(densityfit) {

#ifdef DFT
  if(omega!=0.0)
    throw std::runtime_error("Density fitting not implemented for range separated functionals.\n");
#endif

    if(verbose) {
      printf("Forming density fitted Coulomb matrix ... ");
      fflush(stdout);
      t.set();
    }
    sol.J=dfit.calc_J(sol.P);

    if(verbose) {
      printf("done (%s)\n",t.elapsed().c_str());
      fflush(stdout);
    }

#ifdef DFT
    if(kfull!=0.0) {
#endif
      if(verbose) {
	printf("Forming density fitted exchange matrix ... ");
	fflush(stdout);
	t.set();
      }

#ifdef RESTRICTED
      Kfull=dfit.calc_K(sol.C,occs,fitmem);
#else
      Kafull=dfit.calc_K(sol.Ca,occa,fitmem);
      Kbfull=dfit.calc_K(sol.Cb,occb,fitmem);
#endif

      if(verbose) {
	printf("done (%s)\n",t.elapsed().c_str());
	fflush(stdout);
      }

#ifdef DFT
    }
#endif

  } else { // No density fitting

    if(direct) {
#ifdef RESTRICTED

#ifdef DFT
      if(kfull!=0.0) {
#endif
	if(verbose) {
	  printf("Computing HF Coulomb and exchange matrices.\nScreening integrals with tolerance %.3e ... ",tol);
	  fflush(stdout);
	  t.set();
	}

	if(strictint) {
	  if(!decfock)
	    scr.calcJK(sol.P,sol.J,Kfull,tol,&screeneff);
	  else {
	    // Helper matrices
	    arma::mat Jhlp, Khlp;
	    arma::mat Phlp=decconv*sol.P*arma::trans(decconv);

	    scr.calcJK(Phlp,Jhlp,Khlp,tol,&screeneff);
	    sol.J=arma::trans(decconv)*Jhlp*decconv;
	    Kfull=arma::trans(decconv)*Khlp*decconv;
	  }

	} else {
	  arma::mat dJ, dK;

	  if(!decfock) {
	    scr.calcJK(deltaP,dJ,dK,tol,&screeneff);
	    sol.J+=dJ;
	    Kfull=dK;
	  } else {
	    arma::mat Phlp=decconv*deltaP*arma::trans(decconv);

	    scr.calcJK(Phlp,dJ,dK,tol,&screeneff);
	    sol.J+=arma::trans(decconv)*dJ*decconv;
	    Kfull=arma::trans(decconv)*dK*decconv;
	  }
	}

	if(verbose) {
	  printf("done (%s)\n",t.elapsed().c_str());
	  printf("Due to screening, only %.2f %% of the shell integrals were computed.\n",screeneff);
	  fflush(stdout);
	}

#ifdef DFT
      } else {

	if(verbose) {
	  printf("Computing HF Coulomb matrix.\nScreening integrals with tolerance %.3e ... ",tol);
	  fflush(stdout);
	  t.set();
	}

	if(strictint) {
	  if(!decfock)
	    sol.J=scr.calcJ(sol.P,tol,&screeneff);
	  else {
	    arma::mat Phlp=decconv*sol.P*arma::trans(decconv);
	    arma::mat Jhlp=scr.calcJ(Phlp,tol,&screeneff);
	    sol.J=arma::trans(decconv)*Jhlp*decconv;
	  }

	} else {
	  if(!decfock)
	    sol.J+=scr.calcJ(deltaP,tol,&screeneff);
	  else {
	    arma::mat Phlp=decconv*deltaP*arma::trans(decconv);
	    arma::mat Jhlp=scr.calcJ(Phlp,tol,&screeneff);
	    sol.J+arma::trans(decconv)*Jhlp*decconv;
	  }
	}

	if(verbose) {
	  printf("done (%s)\n",t.elapsed().c_str());
	  printf("Due to screening, only %.2f %% of the shell integrals were computed.\n",screeneff);
	  fflush(stdout);
	}

      }

      if(kshort!=0.0) {
	if(verbose) {
	  printf("Computing screened exchange matrix.\nScreening integrals with tolerance %.3e ... ",tol);
	  fflush(stdout);
	  t.set();
	}

	if(strictint) {
	  if(!decfock)
	    Kshort=scr_rs.calcK(sol.P,tol,&screeneff);
	  else {
	    arma::mat Phlp=decconv*sol.P*arma::trans(decconv);
	    arma::mat Khlp=scr_rs.calcK(Phlp,tol,&screeneff);
	    Kshort=arma::trans(decconv)*Khlp*decconv;
	  }

	} else {
	  if(!decfock)
	    Kshort=scr_rs.calcK(deltaP,tol,&screeneff);
	  else {
	    arma::mat Phlp=decconv*deltaP*arma::trans(decconv);
	    arma::mat Khlp=scr_rs.calcK(Phlp,tol,&screeneff);
	    Kshort=arma::trans(decconv)*Khlp*decconv;
	  }
	}

	if(verbose) {
	  printf("done (%s)\n",t.elapsed().c_str());
	  printf("Due to screening, only %.2f %% of the shell integrals were computed.\n",screeneff);
	  fflush(stdout);
	}
      }
#endif


#else
      // Unrestricted case
#ifdef DFT
      if(kfull!=0.0) {
#endif
	if(verbose) {
	  printf("Computing HF Coulomb and exchange matrices.\nScreening integrals with tolerance %.3e ... ",tol);
	  fflush(stdout);
	  t.set();
	}

	if(strictint) {
	  if(!decfock)
	    scr.calcJK(sol.Pa,sol.Pb,sol.J,Kafull,Kbfull,tol,&screeneff);
	  else {
	    arma::mat Pahlp=decconv*sol.Pa*arma::trans(decconv);
	    arma::mat Pbhlp=decconv*sol.Pb*arma::trans(decconv);

	    arma::mat Jhlp, Kahlp, Kbhlp;
	    scr.calcJK(Pahlp,Pbhlp,Jhlp,Kahlp,Kbhlp,tol,&screeneff);
	    sol.J=arma::trans(decconv)*Jhlp*decconv;
	    Kafull=arma::trans(decconv)*Kahlp*decconv;
	    Kbfull=arma::trans(decconv)*Kbhlp*decconv;
	  }

	} else {
	  // Only calculate the changed part
	  arma::mat dJ, dKa, dKb;

	  if(!decfock) {
	    scr.calcJK(deltaPa,deltaPb,dJ,Kafull,Kbfull,tol,&screeneff);
	    sol.J+=dJ;

	  } else {
	    arma::mat Pahlp=decconv*deltaPa*arma::trans(decconv);
	    arma::mat Pbhlp=decconv*deltaPb*arma::trans(decconv);
	    scr.calcJK(Pahlp,Pbhlp,dJ,dKa,dKb,tol,&screeneff);

	    sol.J+=arma::trans(decconv)*dJ*decconv;
	    Kafull=arma::trans(decconv)*dKa*decconv;
	    Kbfull=arma::trans(decconv)*dKb*decconv;
	  }
	}

	if(verbose) {
	  printf("done (%s)\n",t.elapsed().c_str());
	  printf("Due to screening, only %.2f %% of the shell integrals were computed.\n",screeneff);
	  fflush(stdout);
	}


#ifdef DFT
      } else {

	if(verbose) {
	  printf("Computing HF Coulomb matrix.\nScreening integrals with tolerance %.3e ... ",tol);
	  fflush(stdout);
	  t.set();
	}

	if(strictint) {
	  if(!decfock)
	    sol.J=scr.calcJ(sol.P,tol,&screeneff);
	  else {
	    arma::mat Phlp=decconv*sol.P*arma::trans(decconv);
	    arma::mat Jhlp=scr.calcJ(Phlp,tol,&screeneff);
	    sol.J=arma::trans(decconv)*Jhlp*decconv;
	  }

	} else {
	  if(!decfock)
	    sol.J+=scr.calcJ(deltaP,tol,&screeneff);
	  else {
	    arma::mat Phlp=decconv*deltaP*arma::trans(decconv);
	    arma::mat Jhlp=scr.calcJ(Phlp,tol,&screeneff);
	    sol.J+=arma::trans(decconv)*Jhlp*decconv;
	  }
	}

	if(verbose) {
	  printf("done (%s)\n",t.elapsed().c_str());
	  printf("Due to screening, only %.2f %% of the shell integrals were computed.\n",screeneff);
	  fflush(stdout);
	}

      }


      if(kshort!=0.0) {
	if(verbose) {
	  printf("Computing screened exchange matrix.\nScreening integrals with tolerance %.3e ... ",tol);
	  fflush(stdout);
	  t.set();
	}

	if(strictint) {
	  if(!decfock) {
	    scr_rs.calcK(sol.Pa,sol.Pb,Kashort,Kbshort,tol,&screeneff);
	  } else {
	    arma::mat Pahlp=decconv*sol.Pa*arma::trans(decconv);
	    arma::mat Pbhlp=decconv*sol.Pb*arma::trans(decconv);
	    arma::mat Kahlp, Kbhlp;
	    scr_rs.calcK(Pahlp,Pbhlp,Kahlp,Kbhlp,tol,&screeneff);
	    Kashort=arma::trans(decconv)*Kahlp*decconv;
	    Kbshort=arma::trans(decconv)*Kbhlp*decconv;
	  }

	} else {
	  if(!decfock) {
	    scr_rs.calcK(deltaPa,deltaPb,Kashort,Kbshort,tol,&screeneff);
	  } else {
	    arma::mat Pahlp=decconv*deltaPa*arma::trans(decconv);
	    arma::mat Pbhlp=decconv*deltaPb*arma::trans(decconv);
	    arma::mat Kahlp, Kbhlp;
	    scr_rs.calcK(Pahlp,Pbhlp,Kahlp,Kbhlp,tol,&screeneff);
	    Kashort=arma::trans(decconv)*Kahlp*decconv;
	    Kbshort=arma::trans(decconv)*Kbhlp*decconv;
	  }
	}

	if(verbose) {
	  printf("done (%s)\n",t.elapsed().c_str());
	  printf("Due to screening, only %.2f %% of the shell integrals were computed.\n",screeneff);
	  fflush(stdout);
	}
      }
#endif

#endif
    } else {

      // Conventional mode - use tabled integrals

      if(verbose) {
	printf("Forming HF Coulomb matrix ... ");
	fflush(stdout);
	t.set();
      }

      sol.J=tab.calcJ(sol.P);

      if(verbose) {
	printf("done (%s)\n",t.elapsed().c_str());
	fflush(stdout);
      }

#ifdef DFT
      if(kfull!=0.0) {
#endif

	if(verbose) {
	  printf("Forming HF exchange matrix ... ");
	  fflush(stdout);
	  t.set();
	}

#ifdef RESTRICTED
	if(sol.P_im.n_rows == sol.P.n_rows && sol.P_im.n_cols == sol.P.n_cols) {
	  // Complex density matrix is
	  arma::cx_mat cP(sol.P*COMPLEX1 + sol.P_im*COMPLEXI);
	  arma::cx_mat cK(tab.calcK(cP));
	  Kfull=arma::real(cK);
	  Kfull_im=arma::imag(cK);
	} else
	  Kfull=tab.calcK(sol.P);
#else
	if(sol.Pa_im.n_rows == sol.Pa.n_rows && sol.Pa_im.n_cols == sol.Pa.n_cols) {
	  // Complex density matrix is
	  arma::cx_mat cPa(sol.Pa*COMPLEX1 + sol.Pa_im*COMPLEXI);
	  arma::cx_mat cKa(tab.calcK(cPa));
	  Kafull=arma::real(cKa);
	  Kafull_im=arma::imag(cKa);
	} else
	  Kafull=tab.calcK(sol.Pa);
	
	if(sol.Pb_im.n_rows == sol.Pb.n_rows && sol.Pb_im.n_cols == sol.Pb.n_cols) {
	  // Complex density matrix is
	  arma::cx_mat cPb(sol.Pb*COMPLEX1 + sol.Pb_im*COMPLEXI);
	  arma::cx_mat cKb(tab.calcK(cPb));
	  Kbfull=arma::real(cKb);
	  Kbfull_im=arma::imag(cKb);
	} else
	  Kbfull=tab.calcK(sol.Pb);
#endif

	if(verbose) {
	  printf("done (%s)\n",t.elapsed().c_str());
	  fflush(stdout);
	}
#ifdef DFT
      }
#endif

#ifdef DFT
      if(kshort!=0.0) {

	if(verbose) {
	  printf("Forming short-range HF exchange matrix ... ");
	  fflush(stdout);
	  t.set();
	}

#ifdef RESTRICTED
	if(sol.P_im.n_rows == sol.P.n_rows && sol.P_im.n_cols == sol.P.n_cols) {
	  // Complex density matrix is
	  arma::cx_mat cP(sol.P*COMPLEX1 + sol.P_im*COMPLEXI);
	  arma::cx_mat cK(tab_rs.calcK(cP));
	  Kshort=arma::real(cK);
	  Kshort_im=arma::imag(cK);
	} else
	  Kshort=tab_rs.calcK(sol.P);
#else
	if(sol.Pa_im.n_rows == sol.Pa.n_rows && sol.Pa_im.n_cols == sol.Pa.n_cols) {
	  // Complex density matrix is
	  arma::cx_mat cPa(sol.Pa*COMPLEX1 + sol.Pa_im*COMPLEXI);
	  arma::cx_mat cKa(tab_rs.calcK(cPa));
	  Kashort=arma::real(cKa);
	  Kashort_im=arma::imag(cKa);
	} else
	  Kashort=tab_rs.calcK(sol.Pa);
	
	if(sol.Pb_im.n_rows == sol.Pb.n_rows && sol.Pb_im.n_cols == sol.Pb.n_cols) {
	  // Complex density matrix is
	  arma::cx_mat cPb(sol.Pb*COMPLEX1 + sol.Pb_im*COMPLEXI);
	  arma::cx_mat cKb(tab_rs.calcK(cPb));
	  Kbshort=arma::real(cKb);
	  Kbshort_im=arma::imag(cKb);
	} else
	  Kbshort=tab_rs.calcK(sol.Pb);
#endif
	if(verbose) {
	  printf("done (%s)\n",t.elapsed().c_str());
	  fflush(stdout);
	}
      }
#endif
    }
  }


#ifdef DFT
// Combine short and long range exchanges
#ifdef RESTRICTED
  if(strictint || !direct) {
    sol.K=kfull*Kfull + kshort*Kshort;
    if(sol.P.n_rows == sol.P_im.n_rows && sol.P.n_cols == sol.P_im.n_cols)
      sol.K_im=kfull*Kfull_im + kshort*Kshort_im;
  } else {
    sol.K+=kfull*Kfull + kshort*Kshort;
    sol.K_im.clear();
  }
#else
  if(strictint || !direct) {
    sol.Ka=kfull*Kafull + kshort*Kashort;
    if(sol.Pa.n_rows == sol.Pa_im.n_rows && sol.Pa.n_cols == sol.Pa_im.n_cols)
      sol.Ka_im=kfull*Kafull_im + kshort*Kashort_im;
    
    sol.Kb=kfull*Kbfull + kshort*Kbshort;
    if(sol.Pb.n_rows == sol.Pb_im.n_rows && sol.Pb.n_cols == sol.Pb_im.n_cols)
      sol.Kb_im=kfull*Kbfull_im + kshort*Kbshort_im;
  } else {
    sol.Ka+=kfull*Kafull + kshort*Kashort;
    sol.Ka_im.clear();
    sol.Kb+=kfull*Kbfull + kshort*Kbshort;
    sol.Kb_im.clear();
  }
#endif
#else
  // Hartree-Fock
#ifdef RESTRICTED
  if(strictint || !direct)
    sol.K=Kfull;
  else
    sol.K+=Kfull;
#else
  if(strictint || !direct) {
    sol.Ka=Kafull;
    sol.Kb=Kbfull;
  } else {
    sol.Ka+=Kafull;
    sol.Kb+=Kbfull;
  }
#endif
#endif

#ifdef DFT
  if(verbose) {
    printf("Computing DFT exchange and correlation ... ");
    fflush(stdout);
    t.set();
  }

  double Nelnum; // Numerically integrated density
#ifdef RESTRICTED
  grid.eval_Fxc(dft.x_func,dft.c_func,sol.P,sol.XC,sol.en.Exc,Nelnum);
#else
  grid.eval_Fxc(dft.x_func,dft.c_func,sol.Pa,sol.Pb,sol.XCa,sol.XCb,sol.en.Exc,Nelnum);
#endif

#if defined(FULLHOLE)
  double rel_diff=(Nelnum+1.0-Nel)*100.0/Nel;
#elif defined(HALFHOLE)
  double rel_diff=(Nelnum+0.5-Nel)*100.0/Nel;
#else
  double rel_diff=(Nelnum-Nel)*100.0/Nel;
#endif

  if(verbose) {
    printf("done (%s)\n",t.elapsed().c_str());
    printf("Numerically integrated density is %.5f (%+.4f %%).\n",Nelnum,rel_diff);
  }

  if(fabs(rel_diff)>1e-2) {
    std::ostringstream oss;
    //      oss << "Density integrated over DFT grid differs from number of electrons by " << rel_diff << " %, i.e. " << Nelnum-Nel << " electrons.\n";
    oss << "Warning - numerically integrated density seems inaccurate.\n";
    if(verbose)
      std::cout << oss.str();
    //      throw std::runtime_error(oss.str());
  }

  // Non-local correlation?
  if(dft.nl) {
    if(verbose) {
      printf("Computing non-local correlation ... ");
      fflush(stdout);
      t.set();
    }

#ifdef RESTRICTED
    grid.eval_VV10(nlgrid,dft.vv10_b,dft.vv10_C,sol.P,sol.XC,sol.en.Enl);
#else
    arma::mat XC(sol.XCa);
    XC.zeros();
    grid.eval_VV10(nlgrid,dft.vv10_b,dft.vv10_C,sol.P,XC,sol.en.Enl);
    sol.XCa+=XC;
    sol.XCb+=XC;
#endif

    if(verbose) {
      printf("done (%s)\n",t.elapsed().c_str());
    }
  }
#endif

  // Update Hamiltonian
#ifdef RESTRICTED
#ifdef DFT
  if(sol.Heff.n_elem == Hcore.n_elem)
    sol.H=Hcore+sol.Heff+sol.J+sol.XC;
  else
    sol.H=Hcore+sol.J+sol.XC;
  // Add exact exchange if necessary
  if(kfull!=0.0 || kshort!=0.0) {
    sol.H-=0.5*sol.K;
    sol.en.Exc-=0.25*arma::trace(sol.P*sol.K);
  }

#else
  if(sol.Heff.n_elem == Hcore.n_elem)
    sol.H=Hcore+sol.Heff+sol.J-0.5*sol.K;
  else
    sol.H=Hcore+sol.J-0.5*sol.K;
  sol.en.Exc=-0.25*arma::trace(sol.P*sol.K);
#endif


#else // Unrestricted case

#ifdef DFT
  if(sol.Heffa.n_elem == Hcore.n_elem && sol.Heffb.n_elem == Hcore.n_elem) {
    sol.Ha=Hcore+sol.Heffa+sol.J+sol.XCa;
    sol.Hb=Hcore+sol.Heffb+sol.J+sol.XCb;
  } else {
    sol.Ha=Hcore+sol.J+sol.XCa;
    sol.Hb=Hcore+sol.J+sol.XCb;
  }
  if(kshort!=0.0 || kfull!=0.0) {
    sol.Ha-=sol.Ka;
    sol.Hb-=sol.Kb;
    sol.en.Exc-=0.5*(arma::trace(sol.Pa*sol.Ka)+arma::trace(sol.Pb*sol.Kb));
  }
#else
  if(sol.Heffa.n_elem == Hcore.n_elem && sol.Heffb.n_elem == Hcore.n_elem) {
    sol.Ha=Hcore+sol.J-sol.Ka;
    sol.Hb=Hcore+sol.J-sol.Kb;
  } else {
    sol.Ha=Hcore+sol.J-sol.Ka;
    sol.Hb=Hcore+sol.J-sol.Kb;
  }
  sol.en.Exc=-0.5*(arma::trace(sol.Pa*sol.Ka)+arma::trace(sol.Pb*sol.Kb));

#ifdef _ROHF
  // Constrain Fock operators to correspond to ROHF
  ROHF_update(sol.Ha,sol.Hb,sol.P,S,occa,occb,verbose);
#endif


#endif // end DFT clause
#endif // End unrestricted case


#if defined(FULLHOLE) || defined(HALFHOLE)
  if(freeze.size()>0) {
    // Freeze orbitals for TP/FCH/XCH calculation.
    if(spin)
      freeze_orbs(freeze,sol.Cb,S,sol.Hb,verbose);
    else
      freeze_orbs(freeze,sol.Ca,S,sol.Ha,verbose);
  }
#else
  // Normal case - freeze both alpha and beta spins.
  if(freeze.size()>0) {
#ifdef RESTRICTED
    freeze_orbs(freeze,sol.C,S,sol.H,verbose);
#else
    freeze_orbs(freeze,sol.Ca,S,sol.Ha,verbose);
    freeze_orbs(freeze,sol.Cb,S,sol.Hb,verbose);
#endif
  }
#endif // end TP clause

  fflush(stdout);

  // Energies
  sol.en.Ekin=arma::trace(sol.P*T);
  sol.en.Enuca=arma::trace(sol.P*Vnuc);
  sol.en.Enucr=Enuc;
  sol.en.Eone=arma::trace(sol.P*Hcore);
  sol.en.Ecoul=0.5*arma::trace(sol.P*sol.J);

  // Compute total energies
  sol.en.Eel=sol.en.Ecoul+sol.en.Exc+sol.en.Eone+sol.en.Eeff+sol.en.Enl;
  sol.en.E=sol.en.Eel+sol.en.Enucr;

  // Sanity checks
#ifdef RESTRICTED
  if(!arma::is_finite(sol.H)) {
    ERROR_INFO();
    sol.C.print("C");
    sol.P.print("P");
    sol.H.print("H");
    throw std::runtime_error("Fock operator is not finite.\n");
  }
#else
  if(!arma::is_finite(sol.Ha)) {
    ERROR_INFO();
    sol.Ca.print("Ca");
    sol.Cb.print("Cb");
    sol.Pa.print("Pa");
    sol.Pb.print("Pb");
    sol.Ha.print("Ha");
    sol.Hb.print("Hb");
    throw std::runtime_error("Alpha Fock operator is not finite.\n");
  }
  if(!arma::is_finite(sol.Hb)) {
    ERROR_INFO();
    sol.Ca.print("Ca");
    sol.Cb.print("Cb");
    sol.Pa.print("Pa");
    sol.Pb.print("Pb");
    sol.Ha.print("Ha");
    sol.Hb.print("Hb");
    throw std::runtime_error("Beta Fock operator is not finite.\n");
  }
#endif

  if(!std::isfinite(sol.en.E)) {
    ERROR_INFO();

    // Print out hamiltonians
#ifdef RESTRICTED
    sol.C.print("C");
    sol.P.print("P");
    sol.H.print("H");
#else
    sol.Ca.print("Ca");
    sol.Cb.print("Cb");
    sol.Pa.print("Pa");
    sol.Pb.print("Pb");
    sol.Ha.print("Ha");
    sol.Hb.print("Hb");
#endif

    std::ostringstream oss;
    oss << "\nSomething wrong with total energy " << sol.en.E <<"?\nEnding program.\n";
    throw std::runtime_error(oss.str());
  }
}
